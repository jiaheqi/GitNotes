测试
先提交：python3 manage.py makemigrations
在同步：python3 manage.py migrate
python3 manage.py runserver

(venv) ➜  chaos git:(main) ✗ virtualenv venv --python=3.9                                                                               
(venv) ➜  chaos git:(main) ✗ source venv/bin/activate
(venv) ➜  chaos git:(main) ✗ pip install -r requirements.txt  
运行命令：nosetests -v  test_case
运行某个文件：nosetests -v tests/test_antispam.py
python main.py run  输出的测试报告会写到index.html中


pip3 cache purge
pip3 install mysqlclient==2.0.1



   工作目标：
1. 接口测试不需要在MP里写测试用例，通过自动化来搞。自动化脚本就是用例，可以写测试的时候通过方法的名字，或者备注，来描述用例。
2. 希望你能把测试流程形成一个闭环，维护起来：维护单元测试用例 -> 计划任务执行 -> 对结果监控 -> 当有失败的情况推动开发去修复。
3. 通过阅读发行系统文档来熟悉产品，同时产出测试用例，记录在MP中。 要求按功能模块分类，添加优先级，考虑多个角度： 功能，安全，易用性等等。
4. 在完成3的基础上，接手已经有的UI自动化测试，丰富测试用例，像目标2一样维护管理起来。
5. 把控流程：Zeus的功能改动，在没有经过测试验收前，不能交付上线，对质量负责。 
6. 和产品，开发密切沟通。


https://orcaterm.cloud.tencent.com/terminal?instanceId=lhins-23efs8ph&region=na-siliconvalley&host=43.135.150.180&platformType=LINUX_UNIX&loginMode=tat&from=lh_console_login_btn&loginType=1    root/Xn199231800  这是root权限账号 你试试


自动化接口调试遇到的问题：
1./user/bind-third接口对于用户id和unionid是否存在没有校验，都能返回成功
2.重复绑定也没有校验，每次都可以绑定成功
3.三方登录，传入不存在的type枚举，依旧可以登录成功，需要添加拦截
4.三方登录的时候的token从哪里获取？
5.third-login的union_id 是必填的，但是不传的时候也返回成功
6.secret_token和token的关系，发现传了secret_token之后，token传错误的也能返回成功
7.绑定账号的接口的绑定上限是多少？

-----2023.7.26
8./game/info接口当请求参数为空或者不传，或者为null时候，也能返回：
{
	'error_no': 0,
	'message': '成功',
	'result': {
		'aihelp_appid': '050600_platform_c5487d76a25727d2050d2a2d45c578dc',
		'aihelp_appkey': '050600_app_291aec1bf3cb4c6fb2768fa26d5075ef',
		'aihelp_domain': '050600.aihelp.net',
		'fb_appid': '495405604470359',
		'fb_client_token': '',
		'fb_secret': '0f9b3cf3f86115246dc70b8a72c817a8',
		'freshdesk_appid': '58a3fdd7-879d-471f-9730-40ff1294c67f',
		'freshdesk_appkey': 'e077a8cf-a1f2-42d8-a62b-f6f24a618b79',
		'freshdesk_domain': 'msdk.freshchat.com',
		'game': 'opsgametest',
		'google_client_id': '742111184369-80f14hhsa3fo9rt5ikjhvci749gj7dn8.apps.googleusercontent.com',
		'id': 10009,
		'is_ali_payment_open': 1,
		'is_google_payment_open': 1,
		'is_ios_payment_open': 0,
		'is_recharge_open': 1,
		'is_wechat_payment_open': 1,
		'is_xsolla_payment_open': 0,
		'line_appid': '1654209506',
		'name': 'SDKDemo',
		'platform': 'android',
		'qq_appid': '101479492',
		'sampling_rate': 0,
		'service_mail': 'sys@topjoy.com',
		'shushu_appid': '226d1c95988343a78f35131292ef56af',
		'shushu_host': 'https://oversea-log.topjoy.com/',
		'twitter_key': 'gavLjcKwR7vRvTWV9IerHVQVP',
		'twitter_secret': 'PCzkEeVqOO2wr8UWrG6MJHpXT5492itSzgGUfqX6L1dkxlALmO',
		'wechat_appid': 'wx2e12144bd45d0c79'
	}
}
9.用户注销，表单为空，也返回：0，账号注销成功
用户id为空的时候也返回：0，账号注销成功

10.third-list接口空表单也能正常请求

11.


鹏哥，彩铃，张妍，慧敏，熊老师，希珍，宇宏，虎哥，太玉

Story - 由 Jira Software 创建——请勿编辑或删除。适用于一种用户故事的事务类型。 DEVOPS-4911 Google支付旋转屏幕拉起多个支付问题测试	普通 - Has the potential to affect progress. 完成
删除此链接
描述
1. iOS SDK新增v2支付接口，利用透传参数提高交易订单准确率
2. Unity SDK中，iOS支付升级到v2支付（和1是一个改动点）
3. 优化log打印级别（看一下commit中没有明显不合适的打印即可）
4. ZeusSDK内部打点添加时间校准逻辑（不需要测试）
5. 三方登录和支付添加loading动画（只涉及Android，不涉及IOS）






{"channel":"ApplePay","currency":"","extend":"serverId=3|userId=1011s3p60896|productId=121690268549","notify_cnt":1,"order_id":"bc66d374-467a-487b-b020-c2257b6eec13","pay_amount":0,"pay_notify_url":"http://117.50.187.91:8080/pay/check","pay_time":"2023-07-25T15:03:40.430716031+08:00","product_id":"com.topjoy.zeusdemo.iap1","result":"","sign":"006bf05a5544edf51f721b6993696f65","user_id":1910}

{"channel":"ApplePay","currency":"USD","extend":"serverId=3|userId=1011s3p60896|productId=121690267864","notify_cnt":3,"order_id":"i_20230725145105_xJ9Htf","pay_amount":0.99,"pay_notify_url":"http://117.50.187.91:8080/pay/check","pay_time":"2023-07-25T14:52:09+08:00","product_id":"com.topjoy.zeusdemo.iap1","result":"","sign":"57dbbb5318d944be9202f19cf31ff0b8","user_id":1910}


手机密码：134836
问题记录：
1.支付输入密码之后后台，然后提示支付成功，再恢复到demo，收到两次返回：一次成功，一次payverifyfail
===test:V2支付
resultCode:1,
msg:Success,
result:
{"payResultCode":0,"payRes
ultMsg":"paysuccess","exten
dinfo":"serverld=31
userld=1011s3p608961 productld=121690269924"}
resultCode:0,
msg:Fail,
result:
{"payResultCode":-1,"payRes
ultMsg". "payverifyfail","exten
dinfo"."serverld=31
userld=1011s3p608961 productld=121690269924")
无法复现了，能够复现的情况是：
1.弹出购买成功弹窗后，后台，然后再恢复前台，回调一个payverifyfail
，但其实此时订单已经支付成功

2.v2输入密码完成支付后，二次确认弹窗弹出前，断开网络连接，然后再恢复连接返回paymenttransactionfail：
===test:V2支付
resultCode:O, msg:Fail, result:
{"payResultCode":-1,"payRes ultMsg":"payfail, paymenttransactionfail","extendinfo":"serv erld=31 userld=1011s3p60896l productid=121690275166"}
V1支付同样也会有这个问题

v2输入密码完成支付后，二次确认弹窗弹出后，断开网络连接，然后再恢复连接返回payverifyfail，再次唤起后可以唤起
但是其实这笔订单已经是支付成功的状态了
v1输入密码完成支付后，二次确认弹窗弹出后，断开网络连接，然后再恢复连接返回orderverifyail, networ kerror，再次唤起支付后返回：payverifyfail，再次唤起才能唤起成功
但是其实这笔订单已经是支付成功的状态了


3.选择Line登录之后，返回无法回到SDK了（应该和本次需求无关，需要确认是否是问题及后续是否修改）

4.支付方式选择支付宝支付，但是不支付，返回后，一直处于loading。。（应该和本次需求无关，需要确认是否是问题及后续是否修改）

5.选择非Google支付的时候，系统存在本身的一个loading。。（这个后续优化去掉原先的loading）

6.V2支付的通知项目组信息中的payAmount为0（需要后端改一下）
{
	"channel": "ApplePay",
	"currency": "",
	"extend": "serverId=3|userId=1011s3p60896|productId=121690268549",
	"notify_cnt": 1,
	"order_id": "bc66d374-467a-487b-b020-c2257b6eec13",
	"pay_amount": 0,
	"pay_notify_url": "http://117.50.187.91:8080/pay/check",
	"pay_time": "2023-07-25T15:03:40.430716031+08:00",
	"product_id": "com.topjoy.zeusdemo.iap1",
	"result": "",
	"sign": "006bf05a5544edf51f721b6993696f65",
	"user_id": 1910
}



[用户管理]--用户登录验证
参数校验：
1.空表单
2.参数为空或者nnull
3.参数缺失，只传部分参数
4.userid不存在
5.token无效
正常/异常：
1.正常验证+返回值校验





V2支付正常逻辑：
1.订单1，支付完成，transactionid为123，二次确认弹出前，杀掉进程，重新加载app后，唤起V2支付；
2.生成订单2，此时应该触发transactionid为123的重新处理，更新订单1为支付成功，关联的transactionid为123，订单2状态为未支付。
问题现象：transactionid为123的重新处理没有返回支付成功，返回的是payverifyfail

V1支付逻辑：
1.订单1，支付完成，transactionid为123，二次确认弹出前，杀掉进程，重新加载app后，唤起V2支付；
2.生成订单2，此时应该触发transactionid为123的重新处理，更新订单2为支付成功，关联的transactionid为123，导致订单1状态始终为未支付（因为这种问题的存在，所以才衍生出V2支付）




腾讯MSDK交付流程：https://cloud.tencent.com/developer/article/1132197

开发的心得：
1.接口名称、参数名称要足够清晰
2.一个接口只做一件事。如果有两个比较接近的功能，但是用一个接口实现有点麻烦，那就用两个接口，不要为了减少接口而生硬的把两个接口合为一个
3.接口参数要一定要校验、需要转义或者转换的一定要尽可能早的
避免逻辑走了很长了然后抛出一个校验类型的异常
4.通用的名称要统一
openid,openID,openId,OpenID
WX，wechat，weChat，wx，weixin
5.关于同步和异步接口
可以同步的接口，一定不要异步
能不用全局回调就一定不要用全局的回调
一定要用全局回调最好按照模块分开，一个模块一个回调。开发者只需实现他关心模块的回调即可。无关模块的回调设置与否对SDK的正常使用没有影响；另外每一个回调里最好又能区分回调属于哪次调用的字段。
同一个回调里面的接口尽可能的少，可以合并的尽量合并。

i_20230728114659_PIfcWa



"""
[用户管理]--用户注册：
参数校验
1.空表单，参数全不传
2.表单不为空，参数内容为空或null
3.参数缺失只传其中部分参数：手机信息为空；设备号为空；平台为空
4.不合法的设备号信息
5.使用不存在的force_renew枚举
正常/异常
1.正常登录+返回值校验
2.使用设备ID获取之前的用户信息
3.使用设备ID强制生成新账号
"""


"""
[用户管理]--用户注销：
参数校验
1.空表单，参数全不传
2.表单不为空，参数内容为空或null
3.参数缺失只传其中部分参数：手机信息为空；设备号为空；平台为空
4.不合法的设备号信息
5.使用不存在的force_renew枚举
正常/异常
1.正常登录+返回值校验
2.使用设备ID获取之前的用户信息
3.使用设备ID强制生成新账号
"""


[用户管理]--用户更新：
参数校验
1.空表单，参数全不传
2.表单不为空，参数内容为空或null
3.参数缺失只传其中部分参数：缺少user_id，缺少name
4.user_id不存在
正常/异常
1.正常请求



ORDER BY "#event_time" DESC LIMIT 10

设置为0.5：
10次请求，大约有5次成功上报；测试3次求平均值
1.上报4，不上报6
2.上报3，不上报7
3.上报5，不上报5
20次请求，大约有10次成功上报；测试3次求平均值

两笔请求同时请求，一笔上报，一笔不上报
1.一笔上报，一笔不上报
2.一笔上报，一笔不上报
3.一笔上报，一笔不上报
4.两笔都不上报
5.一笔上报，一笔不上报
-------------------
1.一笔上报，一笔不上报
2.一笔上报，一笔不上报
3.两笔都上报
4.两笔都不上报
5.两笔都不上报
-------------------
1.两笔都不上报
2.一笔上报，一笔不上报
3.一笔上报，一笔不上报
4.一笔上报，一笔不上报
5.两笔都上报

设置为0.3：
10次请求，大约有3次成功上报；测试3次求平均值
20次请求，大约有6次成功上报；测试3次求平均值


请求地址非提供的两个地址，也能正常上报数据；
请求地址是一个错误的地址，比如：哈哈，会上报到network_test_failed中去；
请求协议是TCP的时候，当请求地址包含空格的时候，上报数据报下标越界异常，app闪退；如果协议是HTTP没问题；
请求协议含有空格的时候（协议不存在的时候），sdk无法识别出当前配置；

前端需要添加的校验：
1.用户白名单限制只能输入数字，过滤：汉字，空格，特殊字符等；
2.请求地址也过滤掉：汉字，空格，特殊字符等；
3.请求协议和方法做成下拉菜单，过滤掉不支持的协议
4.采样率设置最多两位小数


第一次用黑泥质地的洗面奶，好好用
我们平时用的大多数的洗面奶是氨基酸泡沫的洗面奶，这种洗面奶可能存在的一个问题就是清洁力度不够。
然后我最近其实用的挺多产品都是爵威尔家的。
我一般会搭配这种非泡沫的洗面奶喝泡沫洗面奶间隔使用，早上用泡沫型的，晚上用非泡沫的，这样不会让皮肤过渡清洁，导致长痘痘或者泛红什么的。
然后这款的话颜色是那种酷黑的，但是起泡后也是白色的泡沫，亲肤干和清洁力度都还不错，主要价格也很便宜大碗，一瓶可以用好久。使用后脸上也很清爽，不会有紧绷的感觉。


海洋味道洗面奶拯救了我的混油皮
我因为平时上课会很长时间的对着电脑，所以导致皮肤会出油很多
经常一模额头就会有很有油脂
然后我又是一个皮肤肤质很脆弱的人，稍微一些刺激的洗面奶用起来就会脸部出红痘子
然后大家买洗面奶的话一定要看一下主要成分
海洋至尊的这款我看主要成分是海藻，海泥还有冰川糖蛋白，会在不刺激的同时减少皮肤的油脂分泌
然后呢亲肤效果也不错，洗脸过后也不会紧紧的，冲洗之后脸部特别清爽
海洋至尊家的洗面奶都是很大一只，真的可以用很久，如果也是混油皮的话大家可以试试嗷


温和又控油的洗面奶好爱
这款米云的洗面奶从外观上面看就是那种比较柔和一点的风格
用起来的感觉和预料中的一样，用过后脸部很舒服，一点不紧绷
然后这款洗面奶的特点是控油和除螨
控油的话应该是油皮同学都需要面临的洗面奶问题
除螨经常被大家忽略，但是尤其是潮湿的天气，一定要多注意一些
这款的洗面奶容量也很足，可以用蛮久的
价格的话也算比较平价，名字也很好听（我特别喜欢这个名字）！


订阅页面打开就闪退

WINY家的首饰的盒子总是给我感觉很舒服又干净的感觉
整体的外包装色调是白色和粉色为主
里面会有一个小袋子的内包装
这个项链的设计是一个两个💍环环相扣的感觉
会有一种永远不分开的象征
上身效果戴起来也很棒，同时也很百搭
七夕马上到了，不知道给男朋友送什么礼物的可以参考下凹

应用后台进前台，切换商品后，唤起支付，支付成功后的确认，orderId为空，然后后端返回被支付订单不存在
exchange返回的成功：
{
	"error_no": 0,
	"message": "成功",
	"result": {
		"order_id": "032e019d-8bbc-4763-9c4b-f9df97cc356e"
	}
}
verify的请求：
{
  "order_id" : "",
  "pay_currency" : "USD",
  "transaction_id" : "2000000383104349",
  "platform" : "ios",
  "pay_amount" : "0.99",
  "sign" : "af1e5a634dc9cb4cd25b77f701d65110",
  "sdk_version" : "2.7.1",
  "appid" : "2YBKKM9W9TX9"
}
verify的返回：
{
	"error_no": 10011,
	"message": "被支付订单不存在"
}


今天预计2.8.0的内容回归完成，不会影响明天的正常发布

1.网络拨测打点数据中是否能区分项目
通过包名bundle_id区分不同项目
2.用HTTPMethod IS NULL 来判断是TCP拨测不合理，需要有明确的字段标记。
新增protocol字段区分类型
3.三方登录和静默登录都可以触发拨测
已经测试了，三方登录和静默登录都可以触发拨测


sandbox2@ouyang.me
YEEM8wea.crey
https://zeus-admin-prerelease.youle.game/
https://zeus-prerelease.youle.game/



Unity的apk http的数据无法采样上传，依赖于某个配置需要存在，如果不存在，只能拨测https，不能拨测http


需求内容：

https://jira.youle.game/browse/DEVOPS-4911

兼容设备和版本：

OPPOA8 Android 9
MI9 Android 11
MEIZU20Pro Android13

VivoX21iA Android9

备注：测试设备有限，暂时兼容了这4个版本

问题：

1.Google支付完成后闪退（已解决）：https://jira.youle.game/browse/DEVOPS-4914
2.唤起后，切换到后台，再恢复到前台，然后支付后还是会闪退（已解决）：https://jira.youle.game/browse/DEVOPS-4914

3.Google支付闪退后重新加载sdk进行支付，一直处于waiting状态（已解决）：https://jira.youle.game/browse/DEVOPS-4915

4.竖屏时Google支付弹窗不展示取消按钮，横屏下展示，恢复竖屏后又出现（弹窗是谷歌的弹窗，所以确认为该问题和我们无关）：https://jira.youle.game/browse/DEVOPS-4917

上线计划：

1.提供2.7.1版本sdk（包含：闪退问题+横竖屏问题修复），用于升级后的项目使用；

2.提供2.5.3版本adk（不存在闪退问题，只包含横竖屏问题修复），用于兼容给不做升级的项目使用

tips：后续更新计划为：优先上线闪退bug的修复，后续再上线横竖屏的支付问题。







需求内容：

https://jira.youle.game/browse/DEVOPS-4843

版本：

跟版2.8.0

问题：

1.https://jira.youle.game/browse/DEVOPS-4969

备注：如果是unity的版本，不支持http的采样，只支持https，如果需要支持http，需要添加支持

上线计划：

1.2.8.0版本：安卓+unity

2.发布时间：2023.08.08



gavLjcKwR7vRvTWV9IerHVQVP
PCzkEeVqOO2wr8UWrG6MJHpXT5492itSzgGUfqX6L1dkxlALmO



"""[防沉迷]--用户实名认证
参数校验：
1.表单为空
2.参数为空或者null
3.参数缺失：缺少id_no,name,account
4.id_no不合法,id_no传空
5.name为空
6.id_no和name不匹配
正常/异常：
1.正常请求
"""

"""[防沉迷]--支付限额
参数校验：
1.表单为空
2.参数为空或者null
正常/异常：
1.正常请求
2.未实名，无配额
3.已实名，成人，无限额
4.已实名，未成年，有限额
"""

"""[防沉迷]--游戏许可
参数校验：
1.表单为空
2.参数为空或者null
正常/异常：
1.正常请求
2.未实名，有限制
3.已实名，成人，无限制
"""


"""[内容安全]--服务端屏蔽字检查
参数校验：
1.表单为空
2.参数为空或者null
正常/异常：
1.正常请求，不拦截，全文通过
2.全文拒绝
3.部分通过，部分拒绝
"""


token=7a6aca0770bf1d70fdf3a22d179df3b2


https://tkw-pay.youle.game/pay_return?merchant_id=zeus2023&pay_way=8

ReturnCode=1&ReturnMsg=%25e6%2588%2590%25e5%258a%259f&PayResult=3&FacTradeSeq=mycard_20230811141743_11juqI&PaymentType=FA200000002&Amount=33.00&Currency=TWD&MyCardTradeNo=MFF230811000056&MyCardType=&PromoCode=A0000&SerialId=&Hash=e967475ff05b605115554df53ab66b1373a449097d3d23d9157ff02c09739959&submit1=Resend




class ServerHTTPClient(object):

    def __init__(self, host, app_id):
        self.host = host
        self.app_id = app_id

    @property
    def headers(self):
        return {
            "content-type": "application/json"
        }
server_http_client = ServerHTTPClient(
    get_host(),
    get_app_id()
)
def generate_jwt_token():
    """
    :return: 生成admin后台接口请求所需要的token
    """
    JWT_SECRET_KEY = "topjoy"
    JWT_ALGORITHM = "HS256"
    user_data = {
        "User": {
            "name": 'chaos',
            "user_id": '999999',
            "is_admin": True,
            "allow_games": [{"alias": "opsgametest", "en_name": "admin"}],
        },
        "exp": 1691856291,
        "iss": "zeus"
    }
    jwt_token = jwt.encode(user_data, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    return jwt_token

class TestGame(TestCase):
    def setUp(self) -> None:
        jwt_token = generate_jwt_token()
        self.jwt_token = jwt_token

    def test_game(self):
        path = "/api/v1/game?alias=opsgametest&_t=1691562726109"
        server_http_client.headers['authorization'] = self.jwt_token
        print(server_http_client.headers)
        response = server_http_client.get(path)





af08623513c145cd86d27c0bc819dd65
ec7bf8ddf9934279abd27500f733c54e


wx2e12144bd45d0c79
9ea04eed100e3bdf13325c8ea4127f1a



Qq登录：8  未安装app的时候会显示扫码登录，扫码登录可以成功登录，但是也会报一个异常

Line登录：3  未安装应用，会跳转到浏览器登录
会弹窗选择浏览器后一直处于waiting状态，日志未见异常（应该和手机安卓的版本有关系，安卓9会有这个问题，安卓13正常）

Twitter登录：2 未安装应用，返回无法完成操作，日志报异常

Facebook登录：1 未安装应用，会通过内嵌浏览器跳转到网业登录，但是facebook拦截了内嵌浏览器登录

Google登录：6 会通过内嵌浏览器登录，可以登陆成功

微信登录：9 安装了微信无法唤起，也会一直处于waiting，无法跳转过去；未安装应用，也一直处于waiting


account不存在，role_id不存在，product_id不存在，server_id不存在，pay_way不存在，pay_status不存在，notify_status不存在，order_attribute不存在


                                                                                                    java.lang.IllegalStateException: Could not find method startGetRemainingTime(View) in a parent or ancestor Context for android:onClick attribute defined on view class android.widget.TextView with id 'getRemainingTime'




be86c9c83c2f9e71875691eab0e1392f28e44f5f




ZeusSDK.getInstance().login(this@MainTxtLogActivity){}是一个匿名函数，而login方法本身需要两个参数public void login(Activity context, MCLoginCallback userObsv){}，为什么使用匿名函数的地方只需要有一个context参数呢,第二个MCLoginCallback参数为什么不需要传递呢





Api/v1/game的post没有改完


api/login的非法token



https://www.googleapis.com/androidpublisher/v3/applications/com.topjoy.sdk_demo
/purchases/subscriptions/com.topjoy.sdk_demo.pay100
/tokens/hgojaodehfkgnpbehakcadjk.AO-J1OzVRrnjkPYnQfLZ9VgA6DqJ62TH9m4-QuAQicXOC3YbEWs5GsuwUPuOLCW62t-H0eqWauq9cqmAohes3hDGYlLVaHmDrg
?access_token=ya29.a0AfB_byDmL4S2fKcTPheMTk4WBX1p9ctJN3FzyLzDWmq8A9RF4nWglBN6rK5YbpbUow93lVVHiERgwF6_DAJ-sZgpGEOTtGQJALYMHh6v9ZCNs-sQ3UIkj8htLfITG5vc-hwPqBbxfpi-eMaXHV_aDY8yVqgLihhVruOJmU6Z350aCgYKAfISARASFQHsvYlsP6K4oiXG5XufNqvpMj_8eg0178



{
	"signature" = "BKy/jkI/eYOTo17CM47Ba7yzwkeq5bPtTu6Ceo7wR9asnhCB04REi2kKO9wbKqmi2iMVAcW5Re88eIHQxVYGgc3rkQ0c9ivLqCXxyiLfRDbLmO8LWh3sIFmO8vD3E/OuvrgjQeocxNnhYoMginjfek7anLL6u0XuUSwnqDXi0e+DfmUjV3/NSXaF5JLaUrNHYRUZAPNhJl1mW6pF287r5RRMkyITBcl+IyydFe+lYlr+Xiife0yBO0C0o4WOcoF7kKZtU6y3x3cjbO8LuM/C0r/Lu1Cfh7wyh6c5DGbl0fLTY1fmoo+55EPRUTHZka2JHvVbiMxK2UnaqGTxZJ8flhEAAAXKMIIFxjCCBK6gAwIBAgIQFeefzlJVCmUBfJHf5O6zWTANBgkqhkiG9w0BAQsFADB1MUQwQgYDVQQDDDtBcHBsZSBXb3JsZHdpZGUgRGV2ZWxvcGVyIFJlbGF0aW9ucyBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTELMAkGA1UECwwCRzUxEzARBgNVBAoMCkFwcGxlIEluYy4xCzAJBgNVBAYTAlVTMB4XDTIyMDkwMjE5MTM1N1oXDTI0MTAwMTE5MTM1NlowgYkxNzA1BgNVBAMMLk1hYyBBcHAgU3RvcmUgYW5kIGlUdW5lcyBTdG9yZSBSZWNlaXB0IFNpZ25pbmcxLDAqBgNVBAsMI0FwcGxlIFdvcmxkd2lkZSBEZXZlbG9wZXIgUmVsYXRpb25zMRMwEQYDVQQKDApBcHBsZSBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALxEzgutajB2r8AJDDR6GWHvvSAN9fpDnhP1rPM8kw7XZZt0wlo3J1Twjs1GOoLMdb8S4Asp7lhroOdCKveHAJ+izKki5m3oDefLD/TQZFuzv41jzcKbYrAp197Ao42tG6T462jbc4YuX8y7IX1ruDhuq+8ig0gT9kSipEac5WLsdDt/N5SidmqIIXsEfKHTs57iNW2njo+w42XWyDMfTo6KA+zpvcwftaeGjgTwkO+6IY5tkmJywYnQmP7jVclWxjR0/vQemkNwYX1+hsJ53VB13Qiw5Ki1ejZ9l/z5SSAd5xJiqGXaPBZY/iZRj5F5qz1bu/ku0ztSBxgw538PmO8CAwEAAaOCAjswggI3MAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUGYuXjUpbYXhX9KVcNRKKOQjjsHUwcAYIKwYBBQUHAQEEZDBiMC0GCCsGAQUFBzAChiFodHRwOi8vY2VydHMuYXBwbGUuY29tL3d3ZHJnNS5kZXIwMQYIKwYBBQUHMAGGJWh0dHA6Ly9vY3NwLmFwcGxlLmNvbS9vY3NwMDMtd3dkcmc1MDUwggEfBgNVHSAEggEWMIIBEjCCAQ4GCiqGSIb3Y2QFBgEwgf8wNwYIKwYBBQUHAgEWK2h0dHBzOi8vd3d3LmFwcGxlLmNvbS9jZXJ0aWZpY2F0ZWF1dGhvcml0eS8wgcMGCCsGAQUFBwICMIG2DIGzUmVsaWFuY2Ugb24gdGhpcyBjZXJ0aWZpY2F0ZSBieSBhbnkgcGFydHkgYXNzdW1lcyBhY2NlcHRhbmNlIG9mIHRoZSB0aGVuIGFwcGxpY2FibGUgc3RhbmRhcmQgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdXNlLCBjZXJ0aWZpY2F0ZSBwb2xpY3kgYW5kIGNlcnRpZmljYXRpb24gcHJhY3RpY2Ugc3RhdGVtZW50cy4wMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL2NybC5hcHBsZS5jb20vd3dkcmc1LmNybDAdBgNVHQ4EFgQUIsk8e2MThb46O8UzqbT6sbCCkxcwDgYDVR0PAQH/BAQDAgeAMBAGCiqGSIb3Y2QGCwEEAgUAMA0GCSqGSIb3DQEBCwUAA4IBAQA8Ru7PqDy4/Z6Dy1Hw9qhR/OIHHYIk3O6SihvqTajqO0+HMpo5Odtb+FvaTY3N+wlKC7HNmhlvTsf9aFs73PlXj5MkSoR0jaAkZ3c5gjkNjy98gYEP7etb+HW0/PPelJG9TIUcfdGOZ2RIggYKsGEkxPBQK1Zars1uwHeAYc8I8qBR5XP5AZETZzL/M3EzOzBPSzAFfC2zOWvfJl2vfLl2BrmuCx9lUFUBzaGzTzlxBDHGSHUVJj9K3yrkgsqOGGXpYLCOhuLWStRzmSStThVObUVIa8YDu3c0Rp1H16Ro9w90QEI3eIQovgIrCg6M3lZJmlDNAnk7jNA6qK+ZHMqB";
	"purchase-info" = "ewoJIm9yaWdpbmFsLXB1cmNoYXNlLWRhdGUtcHN0IiA9ICIyMDIzLTA4LTE0IDAyOjE4OjE3IEFtZXJpY2EvTG9zX0FuZ2VsZXMiOwoJInF1YW50aXR5IiA9ICIxIjsKCSJzdWJzY3JpcHRpb24tZ3JvdXAtaWRlbnRpZmllciIgPSAiMjEzNzI1OTYiOwoJInVuaXF1ZS12ZW5kb3ItaWRlbnRpZmllciIgPSAiRDE1OEM4NEMtNzgyRi00RUEwLUIzMEMtMjQ5NEQwRjJBRkJBIjsKCSJvcmlnaW5hbC1wdXJjaGFzZS1kYXRlLW1zIiA9ICIxNjkyMDA0Njk3MDAwIjsKCSJleHBpcmVzLWRhdGUtZm9ybWF0dGVkIiA9ICIyMDIzLTA4LTE0IDA5OjMzOjEwIEV0Yy9HTVQiOwoJImlzLWluLWludHJvLW9mZmVyLXBlcmlvZCIgPSAiZmFsc2UiOwoJInB1cmNoYXNlLWRhdGUtbXMiID0gIjE2OTIwMDU0MTAwMDAiOwoJImV4cGlyZXMtZGF0ZS1mb3JtYXR0ZWQtcHN0IiA9ICIyMDIzLTA4LTE0IDAyOjMzOjEwIEFtZXJpY2EvTG9zX0FuZ2VsZXMiOwoJImlzLXRyaWFsLXBlcmlvZCIgPSAiZmFsc2UiOwoJIml0ZW0taWQiID0gIjY0NjEzODM4ODkiOwoJInVuaXF1ZS1pZGVudGlmaWVyIiA9ICIwMDAwODExMC0wMDE0NTUxQzBDNkI4MDFFIjsKCSJvcmlnaW5hbC10cmFuc2FjdGlvbi1pZCIgPSAiMjAwMDAwMDM4OTYyMzcyNyI7CgkiZXhwaXJlcy1kYXRlIiA9ICIxNjkyMDA1NTkwMDAwIjsKCSJhcHAtaXRlbS1pZCIgPSAiNjQ1MTE5MDgyNCI7CgkidHJhbnNhY3Rpb24taWQiID0gIjIwMDAwMDAzOTQxODM4MzciOwoJImluLWFwcC1vd25lcnNoaXAtdHlwZSIgPSAiUFVSQ0hBU0VEIjsKCSJidnJzIiA9ICIxIjsKCSJ3ZWItb3JkZXItbGluZS1pdGVtLWlkIiA9ICIyMDAwMDAwMDM0MTcyODMzIjsKCSJiaWQiID0gImNvbS50b3Bqb3kuemV1c2RlbW8iOwoJInByb2R1Y3QtaWQiID0gImNvbS50b3Bqb3kuemV1c2RlbW8uc3ViIjsKCSJwdXJjaGFzZS1kYXRlIiA9ICIyMDIzLTA4LTE0IDA5OjMwOjEwIEV0Yy9HTVQiOwoJInB1cmNoYXNlLWRhdGUtcHN0IiA9ICIyMDIzLTA4LTE0IDAyOjMwOjEwIEFtZXJpY2EvTG9zX0FuZ2VsZXMiOwoJIm9yaWdpbmFsLXB1cmNoYXNlLWRhdGUiID0gIjIwMjMtMDgtMTQgMDk6MTg6MTcgRXRjL0dNVCI7Cn0=";
	"environment" = "Sandbox";
	"pod" = "100";
	"signing-status" = "0";
}



locust -f locustfile.py





1.实现只单独通知失败的用例结果，然后投屏到电视上
一种策略是对于失败的用例自动添加jira的任务，但是可能存在网络问题波动导致用例执行失败，所以暂时先没加
2.如何将自动化用例的执行集成在提测和上线流程中；
3.对于接口的自动化的覆盖率的统计
4.接口的覆盖率和质量上升的可视化
5.SDK是否只通过UI自动化就足够？


微信登录用例：
    def test_third_login_wechat(self):
        """[用户管理]--直接使用第三方登录, 微信登录"""
        path = "/v2/user/third-login"
        body = {
            "device": generate_device_id(),
            "mobile_info": json.dumps(generate_mobile_info()),
            "platform": "android",
            "secret_token": "",
            "token": "0513dy0005Y6tQ1kWU000fuJtT23dy08",
            "type": "9"
        }
        response = sdk_http_client.post(path, body)
        self.assertEqual(response.json().get("error_no"), 0)

微信支付用例：
    def test_wechat_verify_not_pay_order(self):
        """[微信支付]未支付订单确认"""
        path = "/order/wechat-exchange"
        body = {
            "appid": get_app_id(),
            "description": "crystal",
            "device": self.device,
            "extend": self.extend,
            "lang": "1",
            "level": "5",
            "platform": "android",
            "price": "1",
            "product_id": "com.topjoy.sdk_demo.pay100",
            "role_id": self.role_id,
            "role_name": self.role_name,
            "sdk_version": "2.8.0",
            "server_id": "1",
            "server_name": "区服名",
            "user_id": self.user_id,
            "vip": "1",
        }
        response = sdk_http_client.post(path, body)
        order_id = response.json().get('result').get('order_id')
        path = "/order/wechat-verify"
        body = {
            "appid": get_app_id(),
            "order_id": order_id,
            "platform": "android",
            "sdk_version": "2.8.0"
        }
        response = sdk_http_client.post(path, body)
        # {'error_no': 10009, 'message': '订单支付失败'}
        self.assertEqual(response.json().get('error_no'), 10009)




        1.获取skuList和subskulist一直处于waiting
        2.谷歌应用评分返回：fail一直处于waiting
        3.分享接口和制定平台分享接口返回取消，line分享报错


ios订阅确认{'error_no': 10009, 'message': '支付订单认证失败, receipt字段为空'}

用户中心重构的问题：
1.如果绑定的时候，google账号达到绑定上限了，绑定不成功，是不是应该提示一下，现在用户完全感知不出来是因为达到绑定上限了
{"error_no":10003,"message":"该第三方账号绑定已经达到上限"}


已完成测试但是未发布的功能：
安卓：
1.realname、paylimit、getRemainingTime 后端请求需要在 MCZeusService 中重写
2.安卓打点添加trace信息
3.用户中心代码重构：绑定，获取绑定列表等接口 代码使用同一份。

iosv2订阅问题：
1.如果已经成功订阅了项目，然后再次订阅提示已订阅的时候，点击“好”，sdk会去调用一次ios-verify，然后后端会查询不到订单，返回：
{
	"error_no": 10011,
	"message": "订单：9fe6bf6b-df4f-403c-896d-193ec5a6c93c 不存在, record not found"
}
2.而且针对于1的情况就会有多次fail的verify回调，订单号都是同一笔，但是transaction是多笔不一样的，后端返回的是：
{
	"error_no": 10008,
	"message": "订单已被支付"
}
3.输入密码后，支付成功，在没有调用verify之前回调一个失败的回调：paymenttransactionfail，然后verify确认，返回
{
  "message" : "订单：f19fbc62-9d5a-4d61-8945-a441bec6e4e3 不存在, record not found",
  "error_no" : 10011
}
4.感觉会有自动的重试verify，在返回：{
  "message" : "订单：f19fbc62-9d5a-4d61-8945-a441bec6e4e3 不存在, record not found",
  "error_no" : 10011
}
之后，重复调用verify，还是返回不存在
5.有时候点击点阅就直接弹出一个：支付成功



第二道大题是：
现有一个硬件加速器资源，可以通过100000个通道对其下发任务。要求设计一种通道资源管理方案，满足: 
当某个用户需输入-1时。此时资源管理方案分配未使用的最小通道号给用户。
当某个用户输入有效的通道号时，此时资源管理方案回收对应通道，允许之后重新分配。
计算经过一段时间后，下次用户申请时，所申请到的通道号，如无未使用的通道，输出-1。


账号体系的问题：
1.短信验证码校验界面的“重新发送”按钮，现在展示的是“retry”，需要中文还是英文？
2.输入错误的短信验证码之后也不提示错误；
3.短信验证码校验的界面，是否需要加收不到验证码联系客服的选项？
4.用户中心还需要添加邮件和手机号绑定吗？（需要加，本次需求不加，下次用户中心优化的时候再加）
5.用户协议和隐私政策的勾选按钮和loginview中的样式不一致
6.用户协议和隐私政策应该是一个链接还是两个链接？loginview中的是一个，新做的是两个
7.注册的时候没有拦截，如果不勾选用户协议，不允许注册；
8.loginview界面并没有添加邮箱登录的入口;
9.获取区号的接口保一个数组转换为jsonObject的异常
 org.json.JSONException: Value ["+86"] at result of type org.json.JSONArray cannot be converted to JSONObject
2023-08-25 15:44:15.848 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at org.json.JSON.typeMismatch(JSON.java:101)
2023-08-25 15:44:15.848 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at org.json.JSONObject.getJSONObject(JSONObject.java:622)
2023-08-25 15:44:15.848 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at com.topjoy.zeussdk.net.NetUtil$1.onResponse(NetUtil.java:135)
2023-08-25 15:44:15.848 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:519)
2023-08-25 15:44:15.848 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1137)
2023-08-25 15:44:15.849 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:637)
2023-08-25 15:44:15.849 20934-25915 System.err              com.topjoy.sdk_demo                  W  	at java.lang.Thread.run(Thread.java:1012)
10.区号无法自动识别，需要加这个功能吗？
11.手机号的区号下拉菜单只由一个+86；（这个需要后端去加配置文件中的list值：specs/configmap_test.yaml）
12.找回密码界面返回之后，无法返回登录界面，然后还会一直处于loading
13.邮箱登录界面，从注册界面跳转过来的话，无法返回上一级的注册界面
14.邮箱登录成功之后，没有弹窗的“登陆成功”提示


验证码过期的用例增加：短信验证码，邮箱验证码





自动化用例增加：
1.login-with-email
2.third-login的邮箱登录




{"code":10,"msg":"Emaiil不支持解绑","type":11,"status":2}


    public boolean dispatcher(){
        checkBillingAndRetry(new Callback() {
            @Override
            public void onSuccess() {
                MCChoosePayModel.isSupportNewAPI=isFeatureSupported(BillingClient.FeatureType.PRODUCT_DETAILS);
                new MCChoosePayModel();
            }
        });
        return true;
    }

       private void checkBillingAndRetry(Callback back) {
        callback = back;
        isConnected = false;
        tryCount = 0;

        if (billingClient != null && billingClient.isReady()) {
            callback.onSuccess();
            return;
        } else if (billingClient == null) {
            billingClient = BillingClient.newBuilder(MCApiFactoryControl.getInstance().getContext())
                    .setListener(mPurchasesUpdatedListener)
                    .enablePendingPurchases()
                    .build();
        }

        //需要重连
        retry();
    }这里的写法是什么意思？



        private void retry(){
        int maxTryCount = 3;
        if (isConnected || tryCount++ > maxTryCount){
            //已连接或重试次数超过最大次数，执行回调
            if (!isConnected) {
                if (code == BillingClient.BillingResponseCode.USER_CANCELED){
                    //payCancelBackFinish("User canceled");
                    payFail();
                }else{
                    //payFailBackFinish(Pay.BILLING_CLIENT_NOT_READY.jsonWithMsg(tryOverMsg));
                    payFail();
                }
            }else{
                callback.onSuccess();
            }
            return;
        }

            private void checkBillingAndRetry(Callback back) {
        callback = back;
        isConnected = false;
        tryCount = 0;

        if (billingClient != null && billingClient.isReady()) {
            callback.onSuccess();
            return;
        } else if (billingClient == null) {
            billingClient = BillingClient.newBuilder(MCApiFactoryControl.getInstance().getContext())
                    .setListener(mPurchasesUpdatedListener)
                    .enablePendingPurchases()
                    .build();
        }

        //需要重连
        retry();
    }
    retry方法中的callback.onSuccess()是会回调到checkBillingAndRetry中的callback.onSuccess()吗



2023-08-30 15:45:39.512 13696-17032
2023-08-30 15:45:40.504 13696-17032


2023-08-30 15:45:39.509 13696-13696

$.error_no

{"orderId":"GPA.3308-7902-5578-98044","packageName":"com.topjoy.sdk_demo","productId":"com.topjoy.sdk_demo.pay100","purchaseTime":1693386594176,"purchaseState":0,"purchaseToken":"mdglbpoeclnfdjmlmhoofkfc.AO-J1OyLdaPe_drtDcwMNpCIc1nSTE-79K1f15fEzdz69GmYCsBAOPPkPjOdY3lujvQ4WfMlxhc8JKfuGa1o0MKMwME1F2Y_Yg","obfuscatedAccountId":"a_20230830170948_3T8kL4","quantity":1,"acknowledged":false,"developerPayload":"a_20230830170948_3T8kL4"}

{"orderId":"GPA.3308-7902-5578-98044","packageName":"com.topjoy.sdk_demo","productId":"com.topjoy.sdk_demo.pay100","purchaseTime":1693386594176,"purchaseState":0,"purchaseToken":"mdglbpoeclnfdjmlmhoofkfc.AO-J1OyLdaPe_drtDcwMNpCIc1nSTE-79K1f15fEzdz69GmYCsBAOPPkPjOdY3lujvQ4WfMlxhc8JKfuGa1o0MKMwME1F2Y_Yg","obfuscatedAccountId":"a_20230830170948_3T8kL4","quantity":1,"acknowledged":false,"developerPayload":"a_20230830170948_3T8kL4"}




1.如果输入了登录密码，没有输入重复密码，注册提示：请输入重复密码，不需要清空登录密码；
2.如果输入了登录密码，也输入了重复密码，但是不一致，注册提示：两次密码不一致，清空两个输入框，输入光标指示到输入登录密码的输入框


邮箱注册，提示密码不一致：
1.输入了登录密码，重复密码没输入；
2.输入了登录密码，重复密码输入和登录密码不一致
如果这时候跳转到了用户协议，再跳换回来，以上的两种情况的提示就变成了：请输入登录密码，感觉像是之前输入的登录密码就获取不到了

需要确认的问题：
1.在toast中写死的中文的提示怎么做全球化？
2.联系客服的入口的规则；
4.用户协议和隐私政策合在一起还是分开的规则，以及分开的话内容/url是同一个吗？；
都展示两个，如果项目需要一个，传两个一样的url
5.loginview中的入口受admin配置的控制是不是还没做？
6.手机号的位数的判断规则？
统一限制11位


会议纪要：
1.60s更新换手机号允许重新获取验证码 @陈重友
2.限制手机号只能输入数字 @陈重友
3.区号后端配置的时候按照数字大小升序 @童盛
4.手机号绑定不能解绑，做成和邮箱一样的限制 @陈重友
5.输入框：例如输入错误的登录密码的时候，提示我们要求的规则，提示语放在弹窗的位置 ，其他的错误通过toast的提示 @陈重友
6.邮箱注册的输入框提示，重复登录密码调整为确认登录密码 @陈重友
7.显示密码的按钮都加上，现在是密码找回展示，注册不展示 @陈重友
8.用户协议和隐私政策在loginview和短信邮箱的登录注册界面都展示两个入口，如果项目需要一个，传两个一样的url @陈重友
目前的两个url是一样的，调整为不一样的
9.loginview中的入口受admin配置不生效 @陈重友
10.手机号的规则统一限制11位 @陈重友


不同的邮箱类型：163，qq，gmail，等
息屏，前后台

需要补充的回归用例：
1.谷歌订阅的用例
2.ios订阅的用例
3.谷歌的支付取消
4.谷歌的订阅取消


回归的时候的问题：
1.谷歌订阅返回：订单未支付，线上的环境
2.ios的twitter登录闪退，打开用户中心也闪退


功能，交互，易用，安全


1. 发送短信改成每个手机号限制60s
2. 手机号正则校验时区分国内国外（统一限制11位）
3. ✅ 手机号输入框限制只能输入数字
4. ✅ 短信登录取消解绑
5. ✅ 隐私协议：从loginview进入的不显示，接口进入的显示
6. ✅ 密码错误提示：请输入4-20位字母数字特殊字符（密码输入框下）
7. ✅ 邮箱格式：只需要包含@符号
8. 所有格式错误放到输入框下
9. ✅ 请确认登录密码
10. ✅ 维护一个列表支持返回和关闭
11. 登录未注册后端添加一个错误码
12. ✅ 找回密码点击客服按钮跳转，返回时返回到dialog
13. 显示密码

密码错误提示：请输入4-20位字母数字特殊字符（密码输入框下）：fail

谷歌支付没有登录谷歌账号的时候返回：{"code":3007,"msg":"GooglePay onBillingSetupFinished code = 3 msg =Google Play In-app Billing API version is less than 3"}


facebook分享闪退
                E  FATAL EXCEPTION: main
Process: com.topjoy.sdk_demo, PID: 13298
                                                                                                    java.lang.ExceptionInInitializerError
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity.shareFacebook(MCShareActivity.java:184)
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity.access$500(MCShareActivity.java:51)
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity$3.onClick(MCShareActivity.java:169)
                                                                                                    	at android.view.View.performClick(View.java:7570)
                                                                                                    	at android.view.View.performClickInternal(View.java:7540)
                                                                                                    	at android.view.View.-$$Nest$mperformClickInternal(Unknown Source:0)
                                                                                                    	at android.view.View$PerformClick.run(View.java:29710)
                                                                                                    	at android.os.Handler.handleCallback(Handler.java:942)
                                                                                                    	at android.os.Handler.dispatchMessage(Handler.java:99)
                                                                                                    	at android.os.Looper.loopOnce(Looper.java:240)
                                                                                                    	at android.os.Looper.loop(Looper.java:351)
                                                                                                    	at android.app.ActivityThread.main(ActivityThread.java:8416)
                                                                                                    	at java.lang.reflect.Method.invoke(Native Method)
                                                                                                    	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:584)
                                                                                                    	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1013)
                                                                                                    Caused by: The SDK has not been initialized, make sure to call FacebookSdk.sdkInitialize() first.
                                                                                                    	at com.facebook.internal.Validate.sdkInitialized(Validate.kt:117)
                                                                                                    	at com.facebook.FacebookSdk.getCallbackRequestCodeOffset(FacebookSdk.kt:1036)
                                                                                                    	at com.facebook.internal.CallbackManagerImpl$RequestCodeOffset.toRequestCode(CallbackManagerImpl.kt:61)
                                                                                                    	at com.facebook.share.widget.ShareDialog.<clinit>(ShareDialog.kt:394)
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity.shareFacebook(MCShareActivity.java:184) 
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity.access$500(MCShareActivity.java:51) 
                                                                                                    	at com.topjoy.zeussdk.activity.MCShareActivity$3.onClick(MCShareActivity.java:169) 
                                                                                                    	at android.view.View.performClick(View.java:7570) 
                                                                                                    	at android.view.View.performClickInternal(View.java:7540) 
                                                                                                    	at android.view.View.-$$Nest$mperformClickInternal(Unknown Source:0) 
                                                                                                    	at android.view.View$PerformClick.run(View.java:29710) 
                                                                                                    	at android.os.Handler.handleCallback(Handler.java:942) 
                                                                                                    	at android.os.Handler.dispatchMessage(Handler.java:99) 
                                                                                                    	at android.os.Looper.loopOnce(Looper.java:240) 
                                                                                                    	at android.os.Looper.loop(Looper.java:351) 
                                                                                                    	at android.app.ActivityThread.main(ActivityThread.java:8416) 
                                                                                                    	at java.lang.reflect.Method.invoke(Native Method) 
                                                                                                    	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:584) 
                                                                                                    	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1013) 

twitter分享成功，但是code是cancel
数据上传功能，闪退
49f2f609
49f2f609

后端的邮箱注册看起来像不支持含有汉字和特殊符号的邮箱
2023-09-07 10:29:26.644 14163-14163 SDK2.0                  com.topjoy.sdk_demo                  I  MCRequestParamUtil:发送的参数{"appid":"7AVS2D5QH2TV","captcha":"","email":"123..Abc#%@qq.com","password":"Test1234","platform":"android","sdk_version":"2.8.0","sign":"f95643f7166ed20cd864df5af1fddbf4"}
2023-09-07 10:29:26.686 14163-4289  SDK2.0                  com.topjoy.sdk_demo                  E  MCEmailRegisterDialog:{"error_no":1003,"message":"Key: 'RegisterWithEmail.email' Error:Field validation for 'email' failed on the 'isEmail' tag","trace_id":"28bbe2716d8640deb91eae1abe08277c","result":{"trace_id":"28bbe2716d8640deb91eae1abe08277c"},"code":10,"net_name":"register-with-email"}



邮箱账号：
1097099589@qq.com
17600116844@163.com
jiaheqi77@sina.com
jiaheqi@sohu.com
jiaheqi177@gmail.com
jiaheqi@outlook.com
jiaheqi@topjoy.com


 toast("please wait " + MCSMSVerifyDialog.delayTime);



/Users/topjoy/StudioProjects/ZeusSDK/Android/ZeusSDK/app/src/main/java/com/topjoy/sdk_demo/MainTxtLogActivity.kt


com.topjoy.sdk_demo.MainTxtLogActivity

/Users/topjoy/StudioProjects/ZeusSDK/Android/ZeusSDK/app/build/outputs/apk/debug/app-debug.apk


/hierarchy/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.LinearLayout[3]/android.widget.ImageView[1]
/hierarchy/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.LinearLayout[3]/android.widget.ImageView[1]
/hierarchy/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.LinearLayout[3]/android.widget.ImageView[4]


IOS支付订单未持久化导致无法和paymentTransAction完成关联


admin后台配置测试问题：
1.应用新增api/v1/game接口返回：code: 1
message: 
"Key: 'GameInfoCreateForm.appid' Error:Field validation for 'appid' failed on the 'required' tag\nKey: 'GameInfoCreateForm.secret_key' Error:Field validation for 'secret_key' failed on the 'required' tag"
2./user/third-list接口查询结果在设置开关状态更新了后，查询结果没变，如果开关关闭了，返回结果中还是开启
3.谷歌登录sdk返回：resultCode:0|msg:Fail|result:{"code":11,"msg":"10: ","native_code":10,"status":0,"third":6}



接口测试的对于网络问题的重试机制；

    "aihelp_appid"
    "aihelp_appkey"
    "aihelp_domain"
    "is_ali_payment_open": 
    "is_google_payment_open": 
    "is_ios_payment_open": 
    "is_wechat_payment_open": 
    "is_xsolla_payment_open": 
    "shushu_appid": "226d1c95988343a78f35131292ef56af"
    "shushu_host": "https://oversea-log.topjoy.com/"

    "qq_appid": "101479492"


DB0 game_10009
{
    "id": 10009,
    "project_id": 1,
    "name": "SDKDemo",
    "alias": "opsgametest",
    "appid": "7AVS2D5QH2TV",
    "secret_key": "DF864TCE1XWZE1NH",
    "platform": "all",
    "type": "",
    "service_mail": "",
    "google_pay_package_name": "",
    "google_pay_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkWF+w1IrAoID9sndOKVRSd9O+b4DgdHktExKh3FNBGttH/gOwNKNXkjHQhCiApIkqTlgHv4eiQMZiVals2fa3lBZWL6QCMtqKAv+Xvtajy1mJGw0kctBEO36qXj+QgENjtSWxBA+Vkv4TfBwMHPlepHKgYQnoabfs7KW7i1p6StIeu0TsL/wzIBlKPWS+pI48cW+z21HJ2xdQCf+2mwoE+RPUc89G37HHtosO3gb3uuDaRu8wbpygS7EClUV3ocJ22C6B1sC/SIuiFdz5RaJloCR9NLwVrhXKRD7ef718TFT9V6VO8Y1/BmRvUU97dOj00QRaXnKTvopUx7fcRiDYwIDAQAB",
    "google_client_id": "742111184369-80f14hhsa3fo9rt5ikjhvci749gj7dn8.apps.googleusercontent.com",
    "google_client_secret": "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",
    "google_refresh_token": "1//0eFMkCrZ-IRxnCgYIARAAGA4SNwF-L9IrFAKO86aIzl32uBR-3FGJsP35IHXKJIxdd3RpQVK34jaZcJA6C7NRzFHMtRao-ZIu-Q0",
    "google_redirect_uri": "http://localhost",
    "apple_password": "",
    "apple_bundle_id": "com.topjoy.zeusdemo",
    "apple_iss": "e5a4b6e6-0c9d-4702-b444-8a361bf4a17f",
    "apple_key_id": "LML8N38Z9M",
    "apple_secret": "-----BEGIN PRIVATE KEY-----\nMIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgiFaVeqweepF6s1JZ\nwYJxJ26BbRM87PR0wZDWaHX7nbagCgYIKoZIzj0DAQehRANCAAT0HodCCuZsqyd3\n+hL82wmBBhSL4HEZwickLDJMLPdEFVPcj6Bs7f+iuoV2xxte2JCyr2U85NpyiAJ1\nm5lFKCfw\n-----END PRIVATE KEY-----",
    "is_apple_check_transcation_id": false,
    "pay_notify_key": "tkwhant",
    "pay_notify_url": "http://117.50.187.91:8080/pay/check",
    "is_recharge_close": 0,
    "is_recharge_open": 1,
    "is_fb_login": 1,
    "is_tw_login": 1,
    "is_line_login": 0,
    "line_appid": "1654209506",
    "is_gp_login": 0,
    "is_gc_login": 0,
    "is_gi_login": 1,
    "is_ai_login": 0,
    "is_qq_login": 1,
    "is_wechat_login": 1,
    "is_mobile_login": 1,
    "is_email_login": 1,
    "is_apple_id_login": 1,
    "aihelp_appkey": "050600_app_291aec1bf3cb4c6fb2768fa26d5075ef",
    "aihelp_appid": "050600_platform_c5487d76a25727d2050d2a2d45c578dc",
    "aihelp_domain": "050600.aihelp.net",
    "freshdesk_appkey": "e077a8cf-a1f2-42d8-a62b-f6f24a618b79",
    "freshdesk_domain": "msdk.freshchat.com",
    "freshdesk_appid": "58a3fdd7-879d-471f-9730-40ff1294c67f",
    "fb_appid": "495405604470359",
    "fb_secret": "0f9b3cf3f86115246dc70b8a72c817a8",
    "fb_client_token": "c137b67ac1cc6c710cbca8082ec7bb07",
    "twitter_key": "gavLjcKwR7vRvTWV9IerHVQVP",
    "twitter_secret": "PCzkEeVqOO2wr8UWrG6MJHpXT5492itSzgGUfqX6L1dkxlALmO",
    "shushu_appid": "226d1c95988343a78f35131292ef56af",
    "shushu_host": "https://oversea-log.topjoy.com/",
    "status": 1,
    "create_time": "2020-05-14T09:53:50+08:00",
    "update_time": "2023-08-18T10:57:13+08:00",
    "bound_max_count": 2,
    "xsolla_project_id": "654321",
    "xsolla_merchant_id": "123456",
    "xsolla_secret_key": "",
    "is_xsolla_payment_open": 1,
    "wechat_appid": "wx2e12144bd45d0c79",
    "wechat_secret": "9ea04eed100e3bdf13325c8ea4127f1a",
    "is_wechat_payment_open": 1,
    "is_google_payment_open": 0,
    "is_ios_payment_open": 1,
    "is_ali_payment_open": 1,
    "wechat_api_client_key": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC4uzc0iS2d/ai0\nFOhTyXzgdIUY5bWQMWm+MUkUpRwaLf7cUcQGqQyUat/JVps7p2NBwmcR4VvnkJld\ncw5cZA/1tMkMN1wQVqPpfumEBnYXzbnlvQbng6k9XL+wN8ztJzqKpCB0LQin1jJc\nh0IP9U+C6SmgRV9QeEde97ahUtzvdUULIGFAPD3nshlorz0jqZ/oswpaBK6qn6N1\nnN98bJZVFMdZOZTbzWDYEj630L1SyyfX/f8zByhQtjWoHDnULrDEfF+z2TvksRk6\nTMyJuVBYhwEaMJHkjHv61f0pdJHtzBCv0s4EAsIz5huilNAECGlTC9YCWNPcEjuR\nywebH195AgMBAAECggEBAKnU3GT9NKYKXP3qNslI9Ph5xx9jl+9PrlJ/hxtmzBY5\ncRRmS5x/8CPGuaSlbaODORpsuktS7yZN5uFl9K72A0I2CZukjYwryxfQaKjLM+ig\nZyaSCPXxMjdKvKQqOMlShlyNlZSZDlsW7kfoxdBcC9RjvbQt8vnNCniBrjJUNvAh\nQj/R32FQYqy1nlyntGDO9Wm1q4IIwLl02i7PXNKWsADDw9j8DnND/4DpX+5zDGKV\n4V/u0GxabHHMUBH9zFLrFMdmbVyWhFbEq0SxhB6d9GXNBzGhHg5efleIkxLEpCMN\njrVQYL9GZ2BkPUBRe4xlWtDXoK3KS4pwnYzJiUUVAIECgYEA9OuGmcSD9y5sNcFR\nx7/nSktILhdx49U1ODe6s3D2gBp0tnppUZ36uDTqoVzcs2wFBg33zq8Hh60wlQGT\nOUkxcT99Ij7BiVxstwbQwKAi2A8zB6GSHEdP+MOEZnqURlGBc4VFud0XztUXbgoN\nR9v/UXboGTTBrA/lT9LBGAH90kkCgYEAwRahejU4DaGGUsuNd3YBtcBy/emb5yj+\nQrnJkGQcu/9jYFnomTU8++c7I5UxY55NwKba9J0w3VD1Yv9whd2pl80LbDMLRzeB\nD9bLv3/zlZM5EyT5VgjMivDB+TWPCjnBtzQ3ii3hjbiAyfexZ78RKkpwX2BtkwuD\nVtIkNw/ZI7ECgYEAxzvRAsUZlLnuzMu1+wfg3k7fKJ9pxixqXpD3D4GVBCCBUO/D\nPOGGUtK5Cwq/fjUg4Qv7yeYX+gaovo3JdZBU6Ar9gB4M0fCdf0XMCuY5cgjrOgn1\nEYvxQivKSJLui0VCSPbhAZEZDOfLZ3hF1W7hAyP3KooAAjfsEkMfUKhOEgECgYAX\nvOmDNbG7c0UpPp8YtahGKO+6KZMiGxcPKvoNx1EFB8O237bJxxLFQUsy96+HuLmE\nWr8GXaDZRI+2aQLzYinsYKfr2GaljbxPLzADTf6rP9s/cEc6/X/wAONH+P6p2inn\nlQLS+QsGuk0TB2GHCKValqY0A43VCxBNhy4umsMuMQKBgQCehWcKcCSOlk+9rboT\nAsk+jFS2fuRozhmX2yZkf+uzaAxko9cASban0nki4n8yQnEhBLZu4qXKwgRdsZTx\n/4A7+b40NcSEV0p5gUToeXjNss3JtJPqFMjFkF3hsCzmx0tAAMaKmDtwMdFX9nUo\n0EcAHngzXVGVN8r8LXFSwIRieg==\n-----END PRIVATE KEY-----",
    "wechat_mch_id": "1632471809",
    "wechat_mch_sn": "4FF68B2B2037B9C0189117E36D47FB58EBFF1A9E",
    "wechat_mch_api_key": "E4b4eTAPtFvZLKd76Ol4rxE70DPGrrcx",
    "ali_private_key": "MIIEpQIBAAKCAQEA07Ww8ED6DpSVH5pSdT5GYUQU+LtBL1xfmO/12u+rUzTxLWHUsZojBMYWdwhFKtWl5dTJ2O532CrncwgI4XtFCk82v6Y1jvHnPnKozfXiBLVq65iJB+MUgXiw0P65TUQ7W46p7o2Kb/Z0oQ/r5TfEZhZL/OhmrI4grAYjvjLVAE2KsCFfmmJSKlQb+M9T/Xz8UaZz9F6s5EqAZgpLCFSZU5srvtsjwS/jhowCQ1tXSoW1yNmBCQ94ySCqP+ZrECXZyPpCD9dNj0XOMmE1aCX7szEP9Tc4eEP2VHSy0mUYGNQl94iOCu81RJ8JwOQYWTP3DAQ0FCLhFohRmc6JI3W5QwIDAQABAoIBAFjGMli8Vl6wzUtAMd157JcyrjySgMX0TR3bWVOh9kxgwdUO1dpXUOHakmb9b8uDZRpXvQAbFuPtMbpZnye1wgCNsN5yOrkjFJ1qBQDAXzMsQ5ZhEuzcuqeDzVkFxvvwZZeB3h3q+ibyyHsVKwyl8tP/+4MkjJFE08xukqRZullyZo02+0x3wQmKInGJHsZGrHWhmlSpKP1J+4Cm5/qq0fIz4B8tBHhBxvUJZRdwgs5O1mNLjYa25A+k2gbTpz7sjtcCNiP1d2zvZLE25bY1DYJShNra1Xu8B0WtFX0i8CfkkJ9okq0X6o6VAEUNfBwZL1KOL8nGUL3Cyi1PkhT8iPECgYEA/SKggiUZA1rE/Psl7hodf76z66sn0AFBTqDBYvXMLuWnl9G8pb209XJPjdixTXBCt5mxkRu8QKfpbaGjKS21W2deyssVhUeQXqxaSXqjbyl4rU8CD6DYIqKFIy69lKOllVBSc/unY85a6r+mwmBKkAtemcRtyLY6EnkbsOpUfjsCgYEA1hsMP575DMUwdPLEQHRm+pBNG4sblxmdqG0I9XjbQyevpV+uH1GWrdAeJA2bFbQgkyqLnXHj9OnKCK/oyMb9B6ivLRjFz/iTNF1BvZKe3IuoWgdmQi8JzLFKKZEmVRYs6VGQA7Sdxp0zJkxj5o2c3LAgx170uYsdZ+aeX++WWJkCgYEAx5f1DYlo1p9MsdjpyHtpBR/+R/W1t6o1r2TL91auP9AvPGNRJzKVK++NUOAqtU+uG4yhWTSQVD7RrPMFbuOumzq/oJFPD78k07F8o3GCypTdpXGlw2Lk6TJSXjJto3UBi+FAklk8XFMKlwy01ZENWdTNK9uZYOhmk8hQkEfEhZ8CgYEAqsGvpx32qwSpfNwRQQaVCskDdjAftQatAqLTPlNBK/H+1/nTOQ8tCTqujzp6sXiTckvARbWLhMzgYMVK9rYdH3qdG25idVder6igwbyqDmMjxYmZOLejLSlIaJZm5/1jnEF8hjgKjVjabnUGR94xeKDPw7Iro78bmL4JGaJPWiECgYEA4FvanHScNxlhkBgYhpC0LlGRUDodSsOEURZkRBEEOl+QMpnFmY8J6Us0uEwMyyhGohlzFBWVapDr7k0a2cOcMfwhDRrWtLdrB0rhdgLUt/vMs+Lf47opqyD0/YPh8fHrv+EYoHWN8jPrwnrROgFCZB9i7t6OktDKoKMuOVXjjAg=\n\n",
    "ali_app_id": "2021003151622124",
    "ali_pub_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAi6idD6PTJKTf6JHkVmd6iDWpALibowfIddv0aLNMVdsVPr8fCowvyfN9jwQY/VCzQipFwfhYyFuAiraSLw30pFhKCKn9iU3PmKWbhcp4yPOPtLHKar04F/0AyulyRDebfD00U3qVDj0RIDcMmWriktM2F9Q2b8gzrlMWTR9w5QmwefzF7PZzXXA/UFRY3eqPv4uZ1LMdOfwW4KkMQWQIbXuVoMOxPfkeP0l6W9m0Gea5S2a0ddcCayvcuW9cpY/kvDfGnFsiivoiJLig0cwX+EwxbNebQaR/TzO5r3G3Ka7bHBVMN+Qk0WvVu+dudZeNhdmDqRJxn5o6OVVZSMyBWQIDAQAB",
    "qq_appid": "101479492",
    "is_google_subscription_open": 1,
    "is_ios_subscription_open": 0,
    "sampling_rate": 1,
    "apple_client_id": "",
    "apple_client_secret": "",
    "game_server_addr": "",
    "cancel_game_server_addr": "",
    "is_set_pay_notify_url": true,
    "ding_talk_token": "8b2aee720f75e8e970b849663519d826907a8c6fc5815b6bdc7064de98f541ab",
    "mycard_id": "zeus2023",
    "mycard_service_id": "ALF",
    "mycard_secret": "5b2f4b08b9502634de6156f72371ebbb",
    "mycard_sandbox_mode": true,
    "is_mycard_payment_open": 1,
    "gash_configs": {
        "hk": {
            "service_id": "C009210001718",
            "region": "",
            "key": "CckfDshQFWQBBU5Nv90EyMnaApn4lA56",
            "vi": "0vM5PGhYAa8=",
            "password": "sdflkgj62w",
            "sand_box_mode": false
        },
        "hk_staging": {
            "service_id": "C010050003570",
            "region": "",
            "key": "wwkUocgxa+RL4EVaDgKv/IpEafR2CMl8",
            "vi": "psrIAOKfB44=",
            "password": "SDLE5555qaz",
            "sand_box_mode": true
        },
        "tw": {
            "service_id": "C009200001717",
            "region": "",
            "key": "asGSJVl8txtpixIfFciOIOU2F3MPP2R4",
            "vi": "pPwGHDxtBnQ=",
            "password": "ljslKD6WS",
            "sand_box_mode": false
        },
        "tw_stage": {
            "service_id": "C010040003569",
            "region": "",
            "key": "hsPhO6awFZfoIvWULny20DgkeaEc3f63",
            "vi": "CwC2OwQ4QRQ=",
            "password": "fdkjem55qq",
            "sand_box_mode": true
        }
    },
    "is_gash_payment_open": 1,
    "merchant_id": "zeus2023",
    "merchant_secret": "5b2f4b08b9502634de6156f72371ebbb",
    "mycard_configs": {
        "hk": {
            "service_id": "ALFHK",
            "secret": "5b2f4b08b9502634de6156f72371ebbb",
            "sandbox_mode": true
        },
        "tw": {
            "service_id": "ALF",
            "secret": "5b2f4b08b9502634de6156f72371ebbb",
            "sandbox_mode": true
        }
    },
    "antispam_secret_id": "testSecretId1",
    "antispam_secret_key": "testSecretk",
    "antispam_business_id": "testBusinessId",
    "open_status": 1
}



我测试的时候看关闭了开关之后谷歌支付是受影响的，这三个还是可以正常支付

    public static boolean _isFastDoubleClick(final long maxTime) {
        long time = System.currentTimeMillis();
        long timeD = time - mLastClickTime;
        if (0 < timeD && timeD < maxTime) {
            return true;
        }
        mLastClickTime = time;
        return false;
    }
        public static boolean isFastDoubleClick(int time) {
        return _isFastDoubleClick(time);
    }
        private boolean checkValid(Context context, MCOrderInfoBean orderInfo){
        if (!MCNetUtil.isFastDoubleClick(500)) {//如果是快速点击 则不发送请求
            currentOrderInfo = orderInfo;
            Loading.getInstance().show();
            if (MCTextUtil.isEmpty(MCPersonalCenterModel.getInstance().getUserId())) {
                MCLogUtil.cbLog("pay",MCConstant.RESULT_CODE_FAIL,MCConstant.RESULT_MSG_FAIL,"no login");
                MCCallbackBean.fail(MCCallbackBean.getInstance().getPayCallback(), MCConstant.UNITY_CALLBACK_PAY_FAIL_CODE, context.getString(MCInflaterUtil.getIdByName(context, "string", "XG_Recharge_Error_Tip2")));
                return false;
            }
            return true;
        }else{
            MCLogUtil.cbLog("pay", 0, "Fail", "quick click");
            MCCallbackBean.fail(MCCallbackBean.getInstance().getPayCallback(), MCConstant.UNITY_CALLBACK_PAY_FAIL_CODE, Common.QUICK_CLICK.jsonWithMsg(Common.QUICK_CLICK.description()).toString());
            return false;
        }
    }


    private static final String CHECK_EMAIL = "^[a-zA-Z\\d._%!#$&'*+-/=?^`{|}~]+@[a-zA-Z\\d.-]+\\.[a-zA-Z]{2,}$";

   hw_20230912152958_MJrsLa

   hw_20230912152816_zYvNg1
    

    MCGenericCallback3<PurchaseResultInfo> purchaseListener = new MCGenericCallback3<PurchaseResultInfo>() {
        @Override
        public void onSuccess(PurchaseResultInfo result) {
            String inAppPurchaseData = result.getInAppPurchaseData();
            String inAppPurchaseDataSignature = result.getInAppDataSignature();

            verifyPurchase(MCHuaweiPayActivity.this, inAppPurchaseDataSignature, inAppPurchaseData, new MCGenericCallback2<String>() {
                @Override
                public void onSuccess(String result) {
                    onPayResult(MCPayResult.PAY_RESULT_SUCCESS, "huawei pay successfully");
                }

                @Override
                public void onFail(String message) {
                    onPayResult(MCPayResult.PAY_RESULT_FAIL, message);
                }
            });
        }

        @Override
        public void onFail(String message) {
            MCLogUtil.e(TAG, "purchase fail:" + message);
            onPayResult(MCPayResult.PAY_RESULT_FAIL, message);
        }

        @Override
        public void onCancel() {
            MCLogUtil.e(TAG, "purchase cancel");
            onPayResult(MCPayResult.PAY_RESULT_CANCEL, "purchase cancel");
        }
    };
    我这里的写法，onSuccess的参数PurchaseResultInfo从哪来


    public void pay(Context context, MCOrderInfoBean orderInfo, MCPayCallback pck)
                ZeusSDK.getInstance().pay(
                this@MainTxtLogActivity, order
            ){lambda表达式}

我的pay方法是三个参数，但是下面的getInstance()调用pay方法的时候圆括号中只有两个参数，这里的写法是把lambda作为一个参数了吗？


    public void pay(Context context, MCOrderInfoBean orderInfo, MCPayCallback pck) {
        //DONE 转换callback
        MCCommonCallback callback = new MCCommonCallback() {
            @Override
            public void onResult(int resultCode, String msg, String result) {
                if (pck != null)
                    pck.onPayResult(resultCode, msg, result);
            }
        };
        MCLogUtil.logWithUserInfo(
                "pay",
                orderInfo.toString()
        );
        MCChoosePayModel.payType = 0;
        MCApiFactoryControl.getInstance().pay(context, orderInfo, callback);
    }
    MCCommonCallback是一个通用回调，这样写在通用回调的重写方法中，用MCPayCallback的实例去调用重写的onPayResult方法，这样做是什么原因？
    以及MCChoosePayModel.payType = 0;这里给赋值之后有什么作用？

        public static synchronized MCApiFactoryControl getInstance() {
        if (instance == null) {
            instance = new MCApiFactoryControl();
        }
        return instance;
    }

        public static ZeusSDK getInstance() {
        if (null == instance) {
            instance = new ZeusSDK();
        }

        return instance;
    }


    只安装了hms core 没安装应用市场：

    跳转到华为的网页版登录华为账号之后，跳转回来就报这个错误，然后页面一直处于loading
    ZeusSDK:====== pay callback ======resultCode:-1|msg:{"message":"jump huawei login fail,return code:60054,message:current country not supported"}|result:1694573322565

    之后再点击支付报这个错误：
    MCHuaweiPayActivity:purchase fail:huawei iap api fail,purchase,status code:60004,status message:too frequent calls,error message:too frequent calls



    如果是手机安装过应用市场，即使再卸载掉，也能够正常唤起换位支付进行支付


    ZeusSDK:====== pay callback ======resultCode:-1|msg:{"message":"huawei iap api fail,huawei consume fail,status code:60005,status message:network error,error message:network error"}|result:1694585773513

    2023-09-13 14:18:06.444 16273-16273 SDK2.0                  com.topjoy.zeusdemo.huawei           I  ZeusSDK:====== pay callback ======resultCode:-1|msg:{"message":"{\"code\":4,\"msg\":\"Unable to resolve host \\\"zeus.youle.game\\\": No address associated with hostname\",\"net_name\":\"huawei-verify\"}"}|result:1694585869513


    task.addOnSuccessListener(new OnSuccessListener<IsEnvReadyResult>() {}).addOnFailureListener(new OnFailureListener() {} )


    MCZeusService.googleExchange(MCPayModel.Instance().order().getPayNotifyUrl(), cpHandler);
        private final Handler cpHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            MCFlagControl.flag = true;
            switch (msg.what) {
                case MCConstant.GET_GOOGLEPAY_KEY_SUCCESS:
                    Context context = MCApiFactoryControl.getInstance().getContext();
                    MCPayGooglePayBean entity = (MCPayGooglePayBean) msg.obj;
                    Intent intent = new Intent(context, MCGooglePayActivity.class);
                    intent.putExtra("google_public_key", entity.getGoogleKey());
                    intent.putExtra("out_trade_no", entity.getOrderId());
                    context.startActivity(intent);
                    break;
                case MCConstant.GET_GOOGLEPAY_KEY_FAIL:
                    String message = msg.obj.toString();
                    MCLogUtil.w(TAG, message);
                    sendPayResult(MCPayResult.PAY_RESULT_FAIL, message);
                    MCPayModel.Instance().order().setOldPurchaseID(null);
                    break;
                default:
                    break;
            }
        }
    };
    googleExchange()方法中的参数cpHandler的声明逻辑是下面这些，这样的写法是cpHandler作为一个异步回调作为参数是吗？那这个异步回调是做了哪些事情呢？


    消息发送，会触发参数的handler，即上层的cphandler的处理逻辑



    回调的层级包含关系：
     <- MCCommonCallback(ZeusSDK) <-  (MCApiFactoryControl) <- MCCallbackBean(MCPayModel) <- Handler cpHandler(MCChoosePayModel) <- 
    Callback(MCZeusService) <- HandleCallback (MCZeusService.handleResult)


    华为包不支持：
    谷歌登录绑定
    line登录绑定
    微信登录支付

    支持facebook登录绑定

    

The minCompileSdk (33) specified in a
dependency's AAR metadata (META-INF/com/android/build/gradle/aar-metadata.properties)
is greater than this module's compileSdkVersion (android-31).
Dependency: androidx.privacysandbox.ads:ads-adservices-java:1.0.0-beta05.
AAR metadata file: /Users/topjoy/.gradle/caches/transforms-2/files-2.1/7b65c0d6d7270bfc7c72c6d517840849/jetified-ads-adservices-java-1.0.0-beta05/META-INF/com/android/build/gradle/aar-metadata.properties.



 MCCallbackBean.getInstance().getLogCallback().onLogResult("网络请求日志", url, resp);

     private static void handleResult(String resp, String url, HandleCallback callback){
        int status;
        try {
            JSONObject json = new JSONObject(resp);
            status = json.getInt("error_no");
            if (status == 0) {
                callback.success(json);
                MCCallbackBean.getInstance().getLogCallback().onLogResult("网络请求日志", url, resp);
            } else {
                //Tip: zeus service error
                json.put("code", Common.ZEUS_SERVICE_FAIL.code)
                                .put("net_name", NetUtil.splitUrl(url));
                callback.fail(status, json);
            }
        } catch (JSONException e) {
            //Tip: json parsing failed
            try {
                callback.fail(-1, Common.ZEUS_SDK_FAIL.jsonWithMsg(e.getMessage()).put("net_name", splitUrl(url)));
                e.printStackTrace();
            } catch (JSONException ex) {
                e.printStackTrace();
            }
        }
    }

        public MCTextLogCallback getLogCallback() {
        if (logCallback == null) {
            logCallback = new MCTextLogCallback() {
                @Override
                public void onLogResult(String title, String url, String body) {

                }
            };
        }
        return logCallback;
    }
 这里如果满足了status==0的条件，callback.success(json)会去执行哪里的逻辑，MCCallbackBean.getInstance().getLogCallback().onLogResult("网络请求日志", url, resp)会去执行哪里的逻辑？


"gRmkkWsIUAGTfaghVeAMYA4I07MBxauGNzTPc5TgWIh9P5+N+SRsJQsZ3Ucwb+aPqGNKEpr4AIQI5heBDuqbUZua+kF7inCjxJCiqclrcTdE9D+HbnuX1KhCDw4++DfjwSoiXDNTeMu29e6Z0zFWA6lY2PbyS+ySlXHgB7L1G2XwUO0gTb4OxPk+ijGnP4AYpglRdD8cDGPwPG3qKJWprdPKB+PVUdgpUxh5T6gF+x1b7EefPh\/i80OXWUioRgUa+YMDHh2Bii7vLuq8pLkdnD7eVnMZ4tdFSaA1BiDNCzN0zDogUE4pxZaQFuJ2reV5HAo8dWHTkE6qmn85xpByotZlZuFU13DTWcQMOawIsX2hJHPBJUKBa7WEDcsTpnzJBs7KvGG7m3ar\/Tg4HOxoVsjznrKjnfHFN3XQU1CwgLftVXmFMgac3iYGDVdeBT0UuurfsG3DUIH1\/DKXqkd5uWF1ys8Zr9zWtEP7cCuY6dZlnSRjOkK5ikSv5yoAn3AE"
使用python的base64.b64encode编码之后，为什么7m3ar之后的\会变成\\


            "dataSignature": "gRmkkWsIUAGTfaghVeAMYA4I07MBxauGNzTPc5TgWIh9P5+N+SRsJQsZ3Ucwb+aPqGNKEpr4AIQI5heBDuqbUZua+kF7inCjxJCiqclrcTdE9D+HbnuX1KhCDw4++DfjwSoiXDNTeMu29e6Z0zFWA6lY2PbyS+ySlXHgB7L1G2XwUO0gTb4OxPk+ijGnP4AYpglRdD8cDGPwPG3qKJWprdPKB+PVUdgpUxh5T6gF+x1b7EefPh\/i80OXWUioRgUa+YMDHh2Bii7vLuq8pLkdnD7eVnMZ4tdFSaA1BiDNCzN0zDogUE4pxZaQFuJ2reV5HAo8dWHTkE6qmn85xpByotZlZuFU13DTWcQMOawIsX2hJHPBJUKBa7WEDcsTpnzJBs7KvGG7m3ar\/Tg4HOxoVsjznrKjnfHFN3XQU1CwgLftVXmFMgac3iYGDVdeBT0UuurfsG3DUIH1\/DKXqkd5uWF1ys8Zr9zWtEP7cCuY6dZlnSRjOkK5ikSv5yoAn3AE",



2023-09-18 14:28:44.986 15591-15591 SDK2.0                  com.topjoy.sdk_demo                  I  ZeusSDK:====== pay callback ======resultCode:-3|msg:{"orderId":"a_20230918142613_rD9hPU","packageName":"com.topjoy.sdk_demo","productId":"com.topjoy.sdk_demo.pay100","purchaseTime":1695018390870,"purchaseState":0,"purchaseToken":"oobjbfmekigaleipkfelhhei.AO-J1OxKxNsV0WEkzZqG7ydCUMWK8gosHeWn2UJW7oexamiDDU1-0h_tewK29SLtCVZIF51hyjJ4mgANFPJ326Ks3tYC48MGQg","obfuscatedAccountId":"a_20230918142613_rD9hPU","quantity":1,"acknowledged":false,"publicKey":"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkWF+w1IrAoID9sndOKVRSd9O+b4DgdHktExKh3FNBGttH\/gOwNKNXkjHQhCiApIkqTlgHv4eiQMZiVals2fa3lBZWL6QCMtqKAv+Xvtajy1mJGw0kctBEO36qXj+QgENjtSWxBA+Vkv4TfBwMHPlepHKgYQnoabfs7KW7i1p6StIeu0TsL\/wzIBlKPWS+pI48cW+z21HJ2xdQCf+2mwoE+RPUc89G37HHtosO3gb3uuDaRu8wbpygS7EClUV3ocJ22C6B1sC\/SIuiFdz5RaJloCR9NLwVrhXKRD7ef718TFT9V6VO8Y1\/BmRvUU97dOj00QRaXnKTvopUx7fcRiDYwIDAQAB"}|result:1695018523764



1. 调整连续点击时间间隔为500ms（我测试）
2. Google支付verify调整为判断后端error_no参数（我测试）
3. fix：添加获取商品详情回调（开发自测）
4. iOS日志上报（开发自测）
5. 更新demo配置文件（我测试）
6. iOS打点更新（开发自测）
7. 添加华为支付（我测试）
8. fix：修复LINE登录跳转到网页之后返回loading无法取消的问题（这个等下测试一下）
9. SDK适配Android33（这个应该只升级了demo的）

1,2,7我测试


整理待发布内容：

1. 删除v2支付接口
2. 更新iOS证书
3. 用户中心代码重构（统一使用sdk接口）
4. 关闭applovin debug界面
5. 更新LINE SDK（cocopods集成）
6. http请求头添加traceID
7. 更新更多接口的打点
8. 在 MCZeusServer 中重写 paylimit and remaining time 网络请求

1. 重新开始移除成功后跳转切换账号界面的操作
2. unity绑定三方失败后出现绑定成功的回调
3. getbindlist两次失败回调

a_20230918184328_e5lFu3



scp testnotify.py jenkins@172.16.170.71:/Users/jenkins/testnotify

nohup python3 testnotify.py &

https://orcaterm.cloud.tencent.com/terminal?instanceId=lhins-23efs8ph&region=na-siliconvalley&host=43.135.150.180&platformType=LINUX_UNIX&loginMode=tat&from=lh_console_login_btn&loginType=1    root/Xn199231800  这是root权限账号 你试试





http://43.135.150.180/7777



    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.2'
        classpath 'com.google.gms:google-services:4.3.10'
        classpath 'com.google.firebase:firebase-crashlytics-gradle:2.9.1'
        classpath 'io.sentry:sentry-android-gradle-plugin:1.7.36'
        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.1
        0'
    }


    sudo tar -xvf jdk-11.0.19_macos-x64_bin.tar.gz -C /Library/Java/JavaVirtualMachines/

        11.0.20 (x86_64) "Eclipse Adoptium" - "OpenJDK 11.0.20" /Users/topjoy/Library/Java/JavaVirtualMachines/temurin-11.0.20/Contents/Home


        /Users/topjoy/Library/Android/sdk

export ANDROID_HOME=/Users/topjoy/Library/Android/sdk
export ANDROID_SDK_ROOT=/Users/topjoy/Library/Android/sdk


192.168.219.56

    if findByXPath(ids.x_qq_user) is not None:
        findByXPath(ids.x_qq_user).click()
    findClick(ids.id_qq_ok)
    if findByXPath(ids.x_zeus_select_user):
        findByXPath(ids.x_zeus_select_user).click()


    if findByXPath(ids.x_zeus_select_user):
        findByXPath(ids.x_zeus_select_user).click()
test_ali_pay	[支付宝支付]订单创建，正常请求 ：
test_ali_verify_not_pay_order	[支付宝支付]未支付订单确认:支付关闭，admin开关被关闭了
test_bind_twitter	[用户管理]--绑定第三方账号  ：账号绑定上限了，但是为什么会上限呢？
test_get_bind_list	[用户管理]--获取用户已经绑定的第三方账号信息   :因为该用户没有已经绑定的账号导致断言错误
test_bind_with_invalid_type	[用户管理]--绑定第三方账号, 不存在的type ：断言设置有问题，需要调整一下
test_bind_multi_account	[用户管理]--绑定第三方账号, 绑定多个账号：绑定上限了，但是为什么会上限呢？
test_bind_multi_account_over_max	[用户管理]--绑定第三方账号, 绑定多个账号, 超过上限：因为绑定的第一个就失败了，导致断言错误
test_duplicate_bind_twitter	[用户管理]--绑定第三方账号, 重复绑定报错：账号绑定上限了，但是为什么会上限呢？
test_duplicate_unbind_twitter	[用户管理]--绑定第三方账号, 重复解绑报错：因为绑定的时候就没绑定上，导致解绑断言错误
test_unbind_twitter	[用户管理]--解绑第三方账号 ：因为绑定的时候就没绑定上，导致解绑断言错误
test_google_exchange	[google支付]创建Google订单：正常请求：{'error_no': 1003, 'message': '未配置google加密key'}
test_order_ios_exchange	[iosV1支付]创建支付单，正常请求：支付关闭，admin开关被关闭了
test_order_ios_exchange	[iosV2支付]创建支付单，正常请求:支付关闭，admin开关被关闭了
test_order_ios_verify	[iosV2支付确认]已成功订单重复确认: 502 Bad Gateway

test_ios_subscription_exchange	[ios订阅]创建订单，正常请求 : ：支付关闭，admin开关被关闭了
test_get_bind_list	[用户管理]--使用绑定过的第三方账号登录:应该是第一次绑定就没绑定成功导致的
test_get_bind_list	[用户管理]--获取用户已经绑定的第三方账号信息, 绑定多个账号：
test_wechat_pay	[微信支付]订单创建，正常请求：支付关闭，admin开关被关闭了
test_get_bind_list	[用户管理]--获取用户已经绑定的第三方账号信息, 绑定多个账号
{'error_no': 0, 'message': '成功', 'result': {'id': '2444901', 'account': '556039189', 'token': 'VdzCwytYDkwZrmzrNyDwJrpeAtXHoAxe', 'login_time': '2023-09-20 14:52:27'}}



    TODO: 添加邮箱登录的类型
    def test_third_login_email(self):
        """[用户管理]--直接使用第三方登录, email登录"""
        path = "/v2/user/third-login"
        body = {
            "device": "676ecfc91d44fec1",
            "lang": "1",
            "mobile_info": json.dumps(generate_mobile_info()),
            "platform": "android",
            "sdk_version": "2.8.0",
            "secret_token": "",
            "token": "97STQHY4HIYI223N",
            "type": "10",
            "union_id": "jiaheqi@gmail.com"
        }
        response = sdk_http_client.post(path, body)
        self.assertEqual(response.json().get("error_no"), 0)
        self.assertIsNotNone(response.json().get('result').get('id'))
        self.assertIsNotNone(response.json().get('result').get('account'))
        self.assertIsNotNone(response.json().get('result').get('token'))
        self.assertIsNotNone(response.json().get('result').get('login_time'))
package:mine 

 {
	"appid": "7AVS2D5QH2TV",
	"dataSignature": "d8oifRUH9QRvXYxs45G\/Ut7qgekTQuD0qC0PK+\/J25mMEOgzjecXKHRcxYHYLgzpML6KxMz5hUjBDkzLBZDL9QkLZw0TKBLNDzTxkUybJenJim8o7Q+NZERH0NtknCWakOMwoG0yLV9r3VOmw7HImwB94Cz0nEaO7SR2P0ZxO7s0UcxbJPS+dhe2WrBTOf0TlWkBdwO8bMESyHvQwXo+x6mO+Ge8TVBFi79QoFZ9hZkq8N0lTtw0+L\/10UiPxoH3e2fMnkvP4niBhv0nzs+opcW\/D5+XFwMZygw5PprLftPy88np6AkIsiHtMsApidaUF+bQPPsbaLU2god7o7lWR\/5Dk2p3D5o3bOl8IQjNhEhOcI1tLgfKGuCFHr8tP7sDkNQbD3YGg1agSIs4r6X\/NLzKxrcQbIGrlHMBieMN7tmslxt7WLklw7lshEEqkHH4skz3VKkjOtnNiQ0iYJqRDIPQdURaPLgkOKNQMgYwNauuwucbLTDBmVriLTxi\/cHD",
	"developerPayload": "hw_20230920191808_toEPTN",
	"lang": "1",
	"packageName": "com.topjoy.zeusdemo.huawei",
	"pay_amount": "100",
	"pay_currency": "CNY",
	"platform": "android",
	"productId": "zeusdemo.huawei.product01",
	"purchaseToken": "0000018ab2500c26df9c7364d78e2db578519f82ba7660c8233ff3bcc9e6743ba27255a50b7c04dax434e.1.109083613",
	"purchase_data": "{\"autoRenewing\":false,\"orderId\":\"2023092019180984629493eac1.109083613\",\"packageName\":\"com.topjoy.zeusdemo.huawei\",\"applicationId\":109083613,\"applicationIdString\":\"109083613\",\"kind\":0,\"productId\":\"zeusdemo.huawei.product01\",\"productName\":\"元宝1\",\"purchaseTime\":1695208704000,\"purchaseTimeMillis\":1695208704000,\"purchaseState\":0,\"developerPayload\":\"hw_20230920191808_toEPTN\",\"purchaseToken\":\"0000018ab2500c26df9c7364d78e2db578519f82ba7660c8233ff3bcc9e6743ba27255a50b7c04dax434e.1.109083613\",\"consumptionState\":0,\"confirmed\":0,\"purchaseType\":0,\"currency\":\"CNY\",\"price\":100,\"country\":\"CN\",\"payOrderId\":\"sandboxPe160d8654896636f95968e5d0abed13\",\"payType\":\"71\",\"sdkChannel\":\"1\"}",
	"sdk_version": "2.5.3",
	"sign": "4ebe041e52d2f76d1f5d37016334a3f3"
}
2023-09-20 19:19:52.049  3450-3450  SDK2.0                  com.topjoy.zeusdemo.huawei           E  MCHuaweiPayActivity:purchase fail:huawei pay fail,this product need to consume,returnCode:60051

{"error_no":1004,"message":"Error 1406: Data too long for column 'pay_id' at row 1"}


CREATE TABLE `account` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键自增',
  `union_id` varchar(32) NOT NULL COMMENT '用户身份唯一标识',
  `user_name` varchar(20) DEFAULT NULL COMMENT '用户名',
  `email` varchar(32) DEFAULT NULL COMMENT '邮箱',
  `phone` varchar(16) DEFAULT NULL COMMENT '手机号码',
  `password` varchar(128) DEFAULT NULL,
  `token` varchar(32) DEFAULT NULL COMMENT '登陆时生成的token,用于CP服务端登陆验证',
  `register_ip` varchar(32) DEFAULT NULL COMMENT '注册ip',
  `last_login_ip` varchar(32) DEFAULT NULL COMMENT '最近一次登陆ip',
  `register_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `last_login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最近一次登陆时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `union_id` (`union_id`),
  UNIQUE KEY `email` (`email`),
  UNIQUE KEY `phone` (`phone`),
  KEY `register_time` (`register_time`),
  KEY `last_login_time` (`last_login_time`)
) ENGINE=InnoDB AUTO_INCREMENT=10109 DEFAULT CHARSET=utf8mb4 COMMENT='账号信息表';

http://43.135.150.180:8889/login/   
 root/Xn199231800

def logout(request):
    re = redirect('/login/')
    re.delete_cookie('ticket')
    return re


  def logout_view(request):
    re = redirect('/login/')
    logout(request)
    # re.delete_cookie('ticket')
    return re  



1. loginview跳转到短信和邮箱登录，取消之后应该到主界面而不是loginview界面
2. 短信登录，验证码输入框输入之后，等待一会，应用闪退
3. 短信区号下拉菜单的样式调整bug还没改
4. 短信验证码的60s倒计时，时间不会刷新，一直显示的46s，短信验证码无法发送（已修复）
5. 找回密码，未注册的时候，弹出未注册toast提示，不要跳转到输入验证码的dialog
6. 邮箱绑定，注册成功后，验证码输入框未关闭，提示“邮箱已注册，请返回登录”
7. 邮箱注册界面的用户协议没有展示

系统返回按钮，应该返回上一级还是返回主界面？


邀请大家体验一下安卓账号体系的beta版本，一起帮忙发现挖掘一下潜在的bug和易用性问题


我是这样写的，但是会报：AttributeError: 'TestAntispam' object has no attribute 'wrapper'
def retry(max_retries=3, delay_seconds=5):
    """
    装饰器函数，用于在失败时重试函数调用。

    Args:
        max_retries (int): 最大重试次数。
        delay_seconds (int): 重试之间的延迟秒数。
    """

    def decorator(func):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < max_retries:
                try:
                    result = func(*args, **kwargs)
                    return result  # 如果成功，立即返回结果
                except Exception as e:
                    print(f"重试 {retries + 1}/{max_retries}: {e}")
                    time.sleep(delay_seconds)
                    retries += 1
            raise Exception(f"最大重试次数 ({max_retries}) exceeded")

        return wrapper

    return decorator

class TestAntispam(TestCase):
    @retry(max_retries=3, delay_seconds=5)
    def test_antispam_check(self):
        """[内容安全]--服务端屏蔽字检查, 内容通过"""
        path = "/antispam/text-check"
        body = {
            "data_id": generate_device_id(),
            "data": "text",
        }

        response = sdk_http_client.post(path, body)
        self.assertEqual(response.json().get("error_no"), 0)
        self.assertEqual(response.json().get("result").get("check_ret"), 0)
        self.assertEqual(response.json().get("result").get("punish_type"), 0)
        self.assertEqual(response.json().get("result").get("result"), "text")


167106352822505
1f032774ad9a72a319f46e5272fd16e9
6353c2caf3fcdbb210e13844a7e62aab

静默登录 pass

facebook登录 pass
twitter登录 pass
line登录 pass
appleid登录 pass

用户中心登录
facebook登录 pass
twitter登录 pass
line登录 pass
appleid登录 pass

loginview登录
facebook登录 pass
twitter登录 pass
line登录 pass
appleid登录 pass

添加重试的几种方式：
1. nosetests的重试命令启动：
保存失败用例到文件：nosetests --with-id --failed-tests=./failed_tests.txt
执行失败用例的文件：nosetests --failed=./failed_tests.txt
2. run方法中添加对于失败用例的重试逻辑
3. client的post方法添加retry装饰


clickFacebookGetUserInfo

NSLog(@"%@",result);


账号体系发行反馈：
注册和找回密码页面的“请输入4-20位登录密码”修改为“请设置4-20位登录密码” pass 
邮箱绑定的界面的“登录”按钮改为“绑定” pass 
隐私协议和用户协议接口控制是否默认勾选 pass
loginview短信登录按钮icon换为手机的图标 pass
Twitter小鸟icon改为X pass 
后台增加解绑三方账号功能（所有三方渠道）

蝲蛄吟唱的地方（电影《沼泽深处的女孩》原著）
迪莉娅·欧文斯

罗德尼 柏树湾附近钓鱼🎣  

facebook登录 
twitter登录 
line登录 
appleid登录 

用户中心登录
facebook登录 
twitter登录 
line登录 
appleid登录 

loginview登录
facebook登录 
twitter登录 
line登录 
appleid登录 



https://profile.line-scdn.net/OhlZVXy6lzM3V7ISAAw_RNCgtxMB9YUGpnABIsEk4nZUQUEnEmVOEsGOskakNDQ3B3UUZ-REhzbkd3MkQTZXfPQXwRbkRHEHYnXkR5kw

twitter登录报错：
*** Terminating app due to uncaught exception 'TWTRInvalidInitializationException', reason: 'Attempt made to Log in or Like a Tweet without a valid Twitter Kit URL Scheme set up in the app settings. Please see https://dev.twitter.com/twitterkit/ios/installation for more info.'

重置密码成功之后跳转到邮箱绑定的dialog


nosetests /tests/test_huawei_pay.py --with-flaky --force-flaky --max-runs=3


/Users/topjoy/PycharmProjects/chaos/tests/test_huawei_pay.py


nosetests -v tests/test_huawei_pay.py --with-flaky.3
nosetests 

nosetests 


nosetests -v tests/test_huawei_pay.py --force-flaky --max-runs=3 --min-passes=2




我想把这个装饰器放在post方法上，用于实现post请求返回504或者502的时候实现重试，应该怎么调整：
def retry(max_retries=3, delay_seconds=5):
    """
    装饰器函数，用于在失败时重试函数调用。
    Args:
        max_retries (int): 最大重试次数。
        delay_seconds (int): 重试之间的延迟秒数。
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < max_retries:
                try:
                    result = func(*args, **kwargs)
                    return result  # 如果成功，立即返回结果
                except Exception as e:
                    print(f"重试 {retries + 1}/{max_retries}: {e}")
                    time.sleep(delay_seconds)
                    retries += 1
            raise Exception(f"最大重试次数 ({max_retries}) exceeded")
        return wrapper
    return decorator



http://127.0.0.1:4523/m1/3392583-0-default/antispam/text-check


http://127.0.0.1:4523/m1/3392583-0-default/test

    @retry(stop_max_attempt_number=3, wait_fixed=3000)
            if resp.status_code == 504 or resp.status_code == 502:
            print("返回状态码 504or502，进行重试")
            raise Exception("Gateway Timeout")
        else:
            return resp

《被讨厌的勇气：“自我启发之父”阿德勒的哲学课》
岸见一郎 古贺史健
125个笔记

◆ 本书的赞誉

>> 如果说自卑是人类与世界互动的必然结果，那么勇气就是人们在追寻意义人生中的必然能力。

◆ 推荐序二 自我的枷锁和解放

>> 从精神分析创始人弗洛伊德开始，很多心理学家都相信人是过去、尤其是童年经历的产物。这些经历变成了潜意识，决定着我们的人生。

>> 重要的不是过去，而是你怎么看待过去，而我们对过去的看法，是可以改变的。

>> 人们又经常借“爱”之名，行支配和控制之实。

2023/10/09发表想法
在毕业中，加贺也说过这样的话。
>> 我爱你，但与你无关

>> 我爱你，但与你无关

>> 我怎么爱你，这是我的课题，而你要不要接受我的爱，这是你的课题。每个人都守自己的本分，过自己的人生，人和人之间就没那么多纠结和烦恼。

>> 很多人目标远大，觉得只有当上CEO、迎娶白富美、走上人生巅峰，人生才真的开始，现在的生活还不叫“人生”，只能算是在通往人生的路上。当我们这么想的时候，我们就把现在贬低成了实现未来的工具。

>> 当你急着奔向未来的时候，说明你已经不喜欢现在了。

◆ 推荐序三 人唯有在能够感觉自己有价值时，才有勇气

>> 人唯有在能够感觉自己有价值时，才有勇气

◆ 译者序

>> 常常为诸事烦恼的现代人不是缺乏获得幸福的能力，而是缺少获得幸福的勇气！

◆ 引言

2023/10/10发表想法
核心观点

>> 人可以改变、世界极其简单、人人能获得幸福

>> 人可以改变、世界极其简单、人人能获得幸福

>> 幸福的浪漫主义季节转瞬即逝，残酷的现实主义时代终将到来

>> 人并不是住在客观的世界，而是住在自己营造的主观世界里。你所看到的世界不同于我所看到的世界，而且恐怕是不可能与任何人共有的世界

◆ 第一夜 我们的不幸是谁的错？

2023/10/10发表想法
感觉全部在说自己，但是祝福别人的幸福，自己确实是衷心祝愿的
>> 青年自幼就缺乏自信，他对自己的出身、学历甚至容貌都抱有强烈的自卑感。也许是因为这样，他往往过于在意他人的目光

>> 青年自幼就缺乏自信，他对自己的出身、学历甚至容貌都抱有强烈的自卑感。也许是因为这样，他往往过于在意他人的目光

>> 如果一味地关注过去的原因，企图仅仅靠原因去解释事物，那就会陷入“决定论”

2023/10/10发表想法
醍醐灌顶的醐已经醍起来了
>> 也就是说，你的朋友是先有了“不出去”这个目的，之后才会为了达到这个目的而制造出不安或恐惧之类的情绪。阿德勒心理学把这叫作“目的论”

>> 也就是说，你的朋友是先有了“不出去”这个目的，之后才会为了达到这个目的而制造出不安或恐惧之类的情绪。阿德勒心理学把这叫作“目的论”

2023/10/10发表想法
“原因论”的很形象的一个具体例子
>> 假设你因感冒、发高烧而去看医生。如果医生只就引起感冒的原因告诉你说“你之所以会感冒是因为昨天出门的时候穿得太薄”，你对这样的话会满意吗？

>> 假设你因感冒、发高烧而去看医生。如果医生只就引起感冒的原因告诉你说“你之所以会感冒是因为昨天出门的时候穿得太薄”，你对这样的话会满意吗？

>> 决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。

>> 如果闭门不出一直憋在自己房间里的话，父母会非常担心。这就可以把父母的关注集于一身，而且还可以得到父母小心翼翼的照顾。
另一方面，哪怕踏出家门一步，都会沦为无人关注的“大多数”，都会成为茫茫人海中非常平凡的一员，甚至成为逊色于人的平庸之辈；而且，没人会重视自己。这些都是闭居者常有的心理。

>> 您是说愤怒是达成目的的一种手段？

>> 无论过去发生了什么样的事情，现在的状态取决于你赋予既有事件的意义。

>> 您是说问题不在于“发生了什么”，而在于“如何诠释”？

2023/10/11发表想法
人生就像一本答案之书，每个问题都是在我们真正的经历和沉淀之后得出的答案。
>> 为什么那么急于得到答案呢？答案不应该是从别人那里得到，而应该是自己亲自找出来。从别人那里得到的答案只不过是对症疗法而已，没有什么价值

>> 为什么那么急于得到答案呢？答案不应该是从别人那里得到，而应该是自己亲自找出来。从别人那里得到的答案只不过是对症疗法而已，没有什么价值

>> 我还要再次引用阿德勒的话。他这么说：“重要的不是被给予了什么，而是如何去利用被给予的东西

>> 比如现在你感觉不到幸福。有时还会觉得活得很痛苦，甚至想要变成别人。但是，现在的你之所以不幸正是因为你自己亲手选择了“不幸”，而不是因为生来就不幸

>> 某人如何看“世界”，又如何看“自己”，把这些“赋予意义的方式”汇集起来的概念就可以理解为生活方式。从狭义上来讲可以理解为性格；从广义上来说，这个词甚至包含了某人的世界观或人生观

>> 我们假设有一个人正在为“我的性格是悲观的”而苦恼，我们可以试着把他的话换成“我具有悲观的‘世界观’”。我认为问题不在于自己的性格，而在于自己所持有的世界观。性格一词或许会带有“不可改变”这一感觉，但如果是世界观的话，那就有改变的可能性

>> 尽管有些不方便、不自由，但你还是感觉现在的生活方式更好，大概是觉得一直这样不做改变比较轻松吧。如果一直保持“现在的我”，那么如何应对眼前的事情以及其结果会怎样等问题都可以根据经验进行推测，可谓是轻车熟路般的状态。即使遇到点状况也能够想办法对付过去。另一方面，如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦、更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心

>> 例如，你刚才说“如果可以变成Y那样的人就能够幸福”。但像这样活在“如果怎样怎样”之类的假设之中，就根本无法改变。因为“如果可以变成Y那样的人”正是你为自己不做改变找的借口

>> 阿德勒的目的论是说：“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己

◆ 第二夜 一切烦恼都来自人际关系

>> 你认为对她来说最害怕的事情、最想逃避的事情是什么呢？当然是被自己喜欢的男孩拒绝了，是失恋可能带来的打击和自我否定。因为青春期的失恋在这方面的特征非常明显。但是，只要有脸红恐惧症存在，她就可以用“我之所以不能和他交往都是因为这个脸红恐惧症”这样的想法来进行自我逃避，如此便可以不必鼓起告白的勇气或者即使被拒绝也可以说服自己；而且，最终也可以抱着“如果治好了脸红恐惧症我也可以……”之类的想法活在幻想之中

2023/10/11发表想法
又被醍醐灌了一次顶。
>> 就像有脸红恐惧症的她害怕被男性拒绝一样，你也很害怕被他人否定。害怕被别人轻视或拒绝、害怕心灵受伤。你认为与其陷入那种窘境倒还不如一开始就不与任何人有关联。也就是说，你的“目的”是“避免在与他人的关系中受伤

>> 就像有脸红恐惧症的她害怕被男性拒绝一样，你也很害怕被他人否定。害怕被别人轻视或拒绝、害怕心灵受伤。你认为与其陷入那种窘境倒还不如一开始就不与任何人有关联。也就是说，你的“目的”是“避免在与他人的关系中受伤

>> 之所以感觉孤独并不是因为只有你自己一个人，感觉自己被周围的他人、社会和共同体所疏远才会孤独。我们要想体会孤独也需要有他人的存在。也就是说，人只有在社会关系中才会成为“个人”

>> 如果真的成为一个人，也就是只有一个人活在宇宙中的话，那就既不是“个人”，也感觉不到孤独了

>> 只要在某个地方存在着那个某人，孤独就会袭来

>> 我再重复一遍：“人的烦恼皆源于人际关系。”这是阿德勒心理学的一个基本概念。如果这个世界没有人际关系，如果这个宇宙中没有他人只有自己，那么一切烦恼也都将消失

>> 仅止于个人的烦恼，即所谓的“内部烦恼”根本不存在。任何烦恼中都会有他人的因素

>> 高大强壮的男性本身就会给人一种震慑感；而另一方面，矮小的我却能让对方放下警惕心理。看来个子矮小无论是对周围人来说还是对自己来说，都有好处呢！这就是价值的转换

>> 我对自己身高的感觉终究还是在与他人的比较——也就是人际关系——中产生的一种主观上的“自卑感”

>> 困扰我们的自卑感不是“客观性的事实”而是“主观性的解释”

>> 价值必须建立在社会意义之上

>> 我们都有想要摆脱无力状态、追求进步的普遍欲求。人类史上的科学进步也是“追求优越性”的结果。

>> 对于无法达成理想的自己就会产生一种自卑感。

2023/10/11发表想法
自卑感和自卑情结的差异性
>> 自卑感本身并不是坏事。这一点你能够理解吧？就像阿德勒说过的那样，自卑感也可以成为促成努力和进步的契机。例如，虽然对学历抱有自卑感，但若是正因为如此，才下定“我学历低所以更要付出加倍的努力”之类的决心，那反而成了好事。

>> 自卑感本身并不是坏事。这一点你能够理解吧？就像阿德勒说过的那样，自卑感也可以成为促成努力和进步的契机。例如，虽然对学历抱有自卑感，但若是正因为如此，才下定“我学历低所以更要付出加倍的努力”之类的决心，那反而成了好事。

>> 而另一方面，自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。像这样在日常生活中大肆宣扬“因为有A所以才做不到B”这样的理论，这已经超出了自卑感的范畴，它是一种自卑情结。

>> 简单地说就是害怕向前迈进或者是不想真正地努力。不愿意为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。

>> 表现得好像自己很优秀，继而沉浸在一种虚假的优越感之中。
青年：虚假的优越感？
哲人：一个很常见的例子就是“权势张扬”。

>> 特意自吹自擂的人其实是对自己没有自信。阿德勒明确指出“如果有人骄傲自大，那一定是因为他有自卑感”。

>> 最后再举一个关于自夸的复杂实例。这是一种通过把自卑感尖锐化来实现异常优越感的模式。具体就是指夸耀不幸。

>> 也就是暴露出自己的自卑感以当作武器来使用吗？

>> 阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。”

>> 婴儿因为弱势所以不受任何人的支配。

>> 但是，只要把自己的不幸当作保持“特别”的武器来用，那人就会永远需要不幸。

>> 所谓“追求优越性”是指自己不断朝前迈进，而不是比别人高出一等的意思。

>> 您是说人生不是竞争？
哲人：是的。不与任何人竞争，只要自己不断前进即可。当然，也没有必要把自己和别人相比较。

>> 健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。

>> 竞争的可怕之处就在于此。即便不是败者、即便一直立于不败之地，处于竞争之中的人也会一刻不得安心、不想成为败者。而为了不成为败者就必须一直获胜、不能相信他人。之所以有很多人虽然取得了社会性的成功，但却感觉不到幸福，就是因为他们活在竞争之中。因为他们眼中的世界是敌人遍布的危险所在

>> 自己就像是从未真正沐浴过阳光的丝瓜，自然就会因为自卑感而扭曲

>> “无法真心祝福过得幸福的他人”，那就是因为站在竞争的角度来考虑人际关系，把他人的幸福看作“我的失败”，所以才无法给予祝福。

>> 因私愤而流露的发怒只不过是为了让别人屈服的一种工具而已

>> 遭受过父母虐待的孩子有些会误入歧途、逃学，甚至会出现割腕等自残行为。如果按照弗洛伊德的原因论，肯定会从简单的因果律角度归结为：“因为父母用这样的方法教育，所以孩子才变成这样。”就像因为不给植物浇水，所以它们才会干枯一样。这的确是简单易懂的解释。但是，阿德勒式的目的论不会忽视孩子隐藏的目的——也就是“报复父母”。如果自己出现不良行为、逃学，甚至是割腕，那么父母就会烦恼不已，父母还会惊慌失措、痛不欲生。孩子正是因为知道这一点，所以才会出现问题行为。孩子并不是受过去原因（家庭环境）的影响，而是为了达到现在的目的（报复父母）

2023/10/12发表想法
尤其是男女关系的处理中，男生只要任何时候承认错误就对了，无论自己本身有没有错。
>> 承认错误，不代表你失败了

>> 承认错误，不代表你失败了

>> 首先希望你能够理解这样一个事实，那就是发怒是交流的一种形态，而且不使用发怒这种方式也可以交流。我们即使不使用怒气，也可以进行沟通以及取得别人的认同。如果能够从经验中明白这一点，那自然就不会再有怒气产生了。青年：但是，即使对方明显找碴儿挑衅，恶意说一些侮辱性的语言，也不能发怒吗？哲人：你似乎还没有真正理解。不是不能发怒，而是“没必要依赖发怒这一工具”。易怒的人并不是性情急躁，而是不了解发怒以外的有效交流工具。所以才会说“不由得发火”之类的话。这其实是在借助发怒来进行交流

>> 关于权力之争，还有一点需要注意。那就是无论认为自己多么正确，也不要以此为理由去责难对方。这是很多人都容易陷落进去的人际关系圈套

2023/10/12发表想法
有时候很多事并没有真正的孰是孰非，可能对于同一个东西站在了不同的维度和角度，所以在事件的讨论中我们要忽略“我是正确的”这种权力之争的观念。
>> 我是正确的，也就是说对方是错误的。一旦这样想，辩论的焦点便会从“主张的正确性”变成了“人际关系的方式”。也就是说，“我是正确的”这种坚信意味着坚持“对方是错误的”，最终就会演变成“所以我必须获胜”之类的胜负之争。这就是完完全全的权力之争吧？

>> 我是正确的，也就是说对方是错误的。一旦这样想，辩论的焦点便会从“主张的正确性”变成了“人际关系的方式”。也就是说，“我是正确的”这种坚信意味着坚持“对方是错误的”，最终就会演变成“所以我必须获胜”之类的胜负之争。这就是完完全全的权力之争吧？

>> 承认错误、赔礼道歉、退出权力之争，这些都不是“失败”。追求优越性并不是通过与他人的竞争来完成的

>> 如果过度拘泥于胜负就无法作出正确的选择

>> 当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的

>> 哲人：假设你讨厌A这个人，说是因为A身上有让人无法容忍的缺点。青年：是啊，如果是讨厌的人，那还真不少。哲人：但是，那并不是因为无法容忍A的缺点才讨厌他，而是你先有“要讨厌A”这个目的，之后才找出了符合这个目的的缺点。青年：怎么可能？！那我这么做又是为了什么呢？哲人：为了逃避与A之间的人际关系

>> 阿德勒把这种企图设立种种借口来回避人生课题的情况叫作“人生谎言”

>> 阿德勒心理学不是“拥有的心理学”而是“使用的心理学”

>> “不在于被给予了什么，而在于如何去使用被给予的东西”

◆ 第三夜 让干涉你生活的人见鬼去

>> “货币是被铸造的自由。”它是陀思妥耶夫斯基的小说中出现的一句话

>> 基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。只要能够进行课题分离，人际关系就会发生巨大改变

2023/10/12发表想法
那即使对方在你而言觉得达到不了你的要求，也需要信任吗？？？
>> 信任这一行为也需要进行课题分离。信任别人，这是你的课题。但是，如何对待你的信任，那就是对方的课题了。如果不分清界限而是把自己的希望强加给别人的话，那就变成粗暴的“干涉”了。即使对方不如自己所愿也依然能够信任和爱吗？阿德勒所说的“爱的课题”就包括这种追问

>> 信任这一行为也需要进行课题分离。信任别人，这是你的课题。但是，如何对待你的信任，那就是对方的课题了。如果不分清界限而是把自己的希望强加给别人的话，那就变成粗暴的“干涉”了。即使对方不如自己所愿也依然能够信任和爱吗？阿德勒所说的“爱的课题”就包括这种追问

>> 首先要思考一下“这是谁的课题”。然后进行课题分离——哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。而且，不去干涉别人的课题也不让别人干涉自己的课题。这就是阿德勒心理学给出的具体而且有可能彻底改变人际关系烦恼的具有划时代意义的观点

>> 当地流传着这样一个传说：“解开这个绳结的人就会成为亚细亚之王。”这是一个很多技艺高超的挑战者都没有解开的绳结。那么，你认为面对那个绳结的亚历山大大帝会怎么做呢

>> 据传，当时他接着说道：“命运不是靠传说决定而要靠自己的剑开拓出来。我不需要传说的力量而要靠自己的剑去开创命运。”正如你所了解的那样，后来他成了统治自中东至西亚全域的帝王。而“格尔迪奥斯绳结”也成了一段有名的逸闻

>> 选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由

>> 如果想要行使自由，那就需要付出代价。而在人际关系中，自由的代价就是被别人讨厌

>> 即使有人不喜欢你，那也并不是你的课题。并且，“应该喜欢我”或者“我已经这么努力了还不喜欢我也太奇怪了”之类的想法也是一种干涉对方课题的回报式的思维。不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由

◆ 第四夜 要有被讨厌的勇气

>> 例如，在法国使用的世界地图上，美洲大陆位于左端，右端则是亚洲，被绘制在地图中心的是欧洲，是法国。另一方面，如果是中国使用的地图，那么中国就会被绘制在中心位置，美洲大陆在右端、欧洲在左端。也许法国人在看中国版世界地图的时候会产生一种难以名状的不协调感，认为自己被非常不当地赶到了边缘，仿佛世界被任意切割了一样。

>> 如果了解了世界之大，就会明白自己在学校中所受的苦只不过是“杯中风暴”而已。只要跳出杯子，猛烈的风暴也会变成微风。
青年：您是说如果闭门不出就无法到杯子外边去？

>> 这里有需要记住的行动原则。当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是“倾听更大共同体的声音”这一原则。

>> 如果是因为你的反对就能崩塌的关系，那么这种关系从一开始就没有必要缔结，由自己主动舍弃也无所谓。活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。

>> 人怎样才能够获得“勇气”？阿德勒的见解是：人只有在能够感觉自己有价值的时候才可以获得勇气。

>> 对于自己，不要用“行为”标准去考虑，而要首先从“存在”标准上去接纳

>> 我们在看待他人的时候，往往会先任意虚构一个“对自己来说理想的形象”，然后再像做减法一样地去评价

◆ 第五夜 认真的人生“活在当下”

>> 正因为厌恶自己，所以才只关注自己；正因为对自己没有自信，所以才会自我意识过剩

>> “自我接纳”“他者信赖”和“他者贡献”

2023/10/13发表想法
自我肯定和自我接纳的差异性
>> 自我肯定是明明做不到但还是暗示自己说“我能行”或者“我很强”，也可以说是一种容易导致优越情结的想法，是对自己撒谎的生活方式。而另一方面，自我接纳是指假如做不到就诚实地接受这个“做不到的自己”，然后尽量朝着能够做到的方向去努力，不对自己撒谎。

>> 自我肯定是明明做不到但还是暗示自己说“我能行”或者“我很强”，也可以说是一种容易导致优越情结的想法，是对自己撒谎的生活方式。而另一方面，自我接纳是指假如做不到就诚实地接受这个“做不到的自己”，然后尽量朝着能够做到的方向去努力，不对自己撒谎。

>> 说得更明白一些就是，对得了60分的自己说“这次只是运气不好，真正的自己能得100分”，这就是自我肯定；与此相对，在诚实地接受60分的自己的基础上努力思考“如何才能接近100分”，这就是自我接纳

>> 不去关注“无法改变的”，而是去关注“可以改变的”。这就是我所说的自我接纳

2023/10/13发表想法
尼布尔的祈祷文
>> 上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别

>> 上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别

>> 在相信他人的时候不附加任何条件。即使没有足以构成信用的客观依据也依然相信，不考虑抵押之类的事情，无条件地相信。这就是信赖。

>> 请你这样想。我们可以相信也可以怀疑；并且，我们的目标是把别人当作朋友。如此一来，是该选择信任还是怀疑，答案就非常明显了

>> 他者贡献并不是舍弃“我”而为他人效劳，它反而是为了能够体会到“我”的价值而采取的一种手段

2023/10/16发表想法
闭环形成了
>> 为了方便起见，前面我一直按照自我接纳、他者信赖、他者贡献这种顺序来进行说明。但是，这三者是缺一不可的整体。正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”

>> 为了方便起见，前面我一直按照自我接纳、他者信赖、他者贡献这种顺序来进行说明。但是，这三者是缺一不可的整体。正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”

>> 犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。”这种时候，是关注讨厌你的那个人呢？还是聚焦于非常喜欢你的那2个人？抑或是关注其他作为大多数的7个人？缺乏人生和谐的人就会只关注讨厌自己的那个人来判断“世界”

>> 例如，有些问题儿童在上课的时候通过扔橡皮或者是大声说话来妨碍上课，如此一来肯定会引起同学或老师的注意，此刻其就可以成为特别的存在。但这是“廉价的优越性追求”，是一种不健全的态度

>> “复仇”和“廉价的优越性追求”很容易联系起来。这就是在让对方烦恼的同时还想成为“特别的存在”

>> 人生是一连串的刹那

>> 用别的话说也可以理解为“把过程本身也看作结果的运动”，跳舞是如此，旅行等本身也是如此

>> 请你想象一下自己站在剧场舞台上的样子。此时，如果整个会场都开着灯，那就可以看到观众席的最里边。但是，如果强烈的聚光灯打向自己，那就连最前排也看不见。我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来

>> 人生是连续的刹那，根本不存在过去和未来

>> 站在现实性角度的时候，人生总是处于完结状态

>> 你还有我，即使生命终结于“此时此刻”，那也并不足以称为不幸。无论是20岁终结的人生还是90岁终结的人生，全都是完结的、幸福的人生

>> 人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言

>> 只要自己心中有他者贡献这颗星就一定能够有幸福相伴，有朋友相伴

>> 我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方

◆ 后记

>> 人只有在社会背景下才能成为个人



"order_id": "73b62231-b437-442e-81a2-7c04e3e2b265"
	}


    "order_id": "835bba2b-98b9-4a7f-ab94-2048fb5ec5ea"


"result": "{\"code\":5,\"msg\":\"GooglePay onPurchasesUpdated: responseCode:7 debugMessage:Account identifiers don't match the previous subscription.\",\"payOrderInfo\":\"MCOrderInfoBean{product_id='com.topjoy.sdk8', oldPurchaseId='null', price=99, amount=3.49, currency='USD', extendInfo='1697513552776', serverId='1', serverName='区服名', roleId='123123', roleName='charlott-', roleVIP='1', roleLevel='5', isSubscription='1', payNotifyUrl='http:\\\/\\\/192.168.148.83:8000\\\/'}\",\"payResultCode\":-1,\"extendInfo\":\"1697513552776\"}",


 /var/installd/Library/Caches/com.apple.mobile.installd.staging/temp.rKlQxv/extracted/Payload/ZeusSDKDemo.app : 0xe8008001 (An unknown error has occurred.)


 订阅：
 杀进程后初始化之后自动恢复购买，好像没有；


 1.假如没有finished的订单，如果再次发起订阅，会不会提示已订阅；
 

 864267


            "id_no": "522601196404090816",
            "name": "王华平",



path = "/api/v1/orders/notify"
1.订单未支付，调用是补发
2.订单已支付，未通知调用是补单

问题记录：
1./api/v1/orders/notify对于gameid没有校验；
2./api/v1/orders/google_fix对于product_id，game_1没有校验
3.对于各种错误的code没有做区别处理，都返回1
{'code': 1, 'message': '订单未支付或者已经通知Game Server，请登录管理后台查看订单支付状态'}
{'code': 1, 'message': '票据信息异常，未获取到订单信息'}


2000000387360815



paylimit
1.8-16岁：
2.16-18岁：
3.小于8岁：

返回值是0
{
	"accumulation_limit": 0,
	"transaction_limit": 0,
	"accumulation_amount": 198.01,
	"remaining_amount": -198.01,
	"start_time": "2023-10-01 00:00:00",
	"end_time": "2023-10-31 00:00:00",
	"allow": false
}
返回值是小数
 {
	"accumulation_limit": 2.147483648E7,
	"transaction_limit": 2.147483648E7,
	"accumulation_amount": 0,
	"remaining_amount": 2.147483648E7,
	"start_time": "2023-10-01 00:00:00",
	"end_time": "2023-10-31 00:00:00",
	"allow": true
}
返回值是整数


如果项目请求paylimit传的类型是double如100.00，sdk会认为单位是元，sdk会乘以100为10000的int类型去请求后端；
如果项目请求paylimit传的类型是int如100，sdk会认为单位是分，sdk直接用100作为int类型去请求后端；



安卓：
登录 pass
三方登录 pass line
绑定解绑 pass  手机 line
支付 pass
订阅 pass
用户中心pass
实名认证pass
twitter和line头像：
账号体系：
登录：短信，邮箱pass
注册：短信，邮箱pass
绑定：短信，邮箱pass
密码找回：短信，邮箱pass



ios：
登录pass
三方登录 twitter失败 facebook
绑定解绑pass
支付pass
订阅pass
用户中心
实名认证pass ios的修改没同步
google和line头像：
账号体系：
登录：短信，邮箱 pass
注册：短信，邮箱pass
绑定：短信，邮箱pass
密码找回：短信，邮箱pass


 {"error_no":1004,"message":"Error 1366: Incorrect string value: '\\xF0\\x9F\\x8D\\x88 S...' for column 'role_name' at row 1"}



 获取头像，本身没有头像的情况；
 之前保存的头像，如果切换账号之后没有清除


 


 ck2648967@gmail.com
 name123456
line账号
test
test1234A

game id常量
订单存在和不存在的setup
payway setup





“feature finish” 命令会把我们的工作整合到主 “develop” 分支中去
这里的develop就类似于我们的pre-release

开发功能分支----develop-----release（prelease）---master（release）
修复分支fix（从master拉取）------同步master--更新到prelease和开发分支


1.手机号注册无法输入验证码（需要调整）
适配问题，模拟器确实无法输入，邮箱的验证码也无法输入
2.邮箱找回密过程中，点击确认无任何反馈
这个问题已经解决
3.收不到验证码？（黑色），联系客服红色。做出点击区域的区分（需求）
这个是个需求，需要看下我们是否调整，因为我们目前的也只是个文案，不涉及跳转
4.邮箱找回密码无效后或者手机号接受验证码失败后，关闭找回界面卡死。（需要调整）
问题现象有两个，需要我们调整：
（1）弹窗的dialog直接关闭后，无法弹出“开始游戏”，导致只能杀掉进程了
（2）手机系统物理键的返回后，可以看到“开始游戏”，但是点击没反应
5.邮箱登录后杀进程，重新登录没继承登录状态，需要重新输入登录（需要调整）
这个就是我们要做的自动登录
6.邮箱找回密码，输入信息后，点击“确认重置”无任何反应。
同问题2已经解决
7.任何操作过程中点击X后，无法回到初始登陆界面。建议不提供 X选项。
这个同4，看下我们怎么调整。


2023-10-30 10:54:00.240
2023-10-30 10:54:00.448

同一笔请求，如果前一笔成功了，后一笔返回了{"error_no":10007,"message":"Google订单重复, 无法完成支付操作"}，订单状态还会被更新为失败吗？

i_20231030110738_ebQun9


### 自动调用recover测试场景：
ios：
构造未确认订单：
1.杀掉进程后，重新打开，不初始化，不会自动调用verify；
2.杀掉进程后，重新打开，初始化，不登录，不会自动调用verify；
3.杀掉进程后，重新打开，初始化，登录：自动调用verify；pass
4.后台应用，再进入前台；
支付有问题，测不了

android：
构造未确认订单：
1.杀掉进程后，重新打开，不初始化，自动调用verify；pass
2.杀掉进程后，重新打开，初始化，不登录，自动调用verify；
3.杀掉进程后，重新打开，初始化，登录：自动调用verify；pass
4.后台应用，再进入前台，自动调用verify；pass


登录成功调用 recover
后台切换到前台调用 recover

ios：
调整之前：
1. 初始化和登录之后都不会自动调用恢复订单，再次点击支付的时候会去调用恢复订单
2. 后台之后已经发起的verify请求会中断，返回前台后会自动发起新的verify，会成功
调整之后：
支付遇到了问题，无法测试（已修复）
每次支付完成后会有两次verify调用（已修复）
1. 如果存在未确认的订单，重新打开进程，初始化登录后，自动调用recover恢复订单
2. 后台之后已经发起的verify请求会中断，返回前台后会自动发起新的verify，会成功
   还会有一个后台到前台的verify，也会成功。
3. 正常后台切前台切换也会调用recover，如果不存在待恢复订单，不会请求后端的接口，如果存在，会请求后端verify。

调用恢复订单的时候返回了：
"order_id": "i_20231030173408_8K3wJf"
{
	"error_no": 10007,
	"message": "苹果支付订单重复, 无法完成支付操作"
}

安卓：
调整之前：
1. 如果存在未确认的订单，重新打开进程之后初始化不会恢复订单，登录也不会恢复订单，只有再次点击支付的时候会调用恢复订单；
2. 支付未完成，后台之后已经发起的verify请求会中断，返回前台后会自动发起新的verify，会成功；
3. 正常后台切前台切换，不会调用recover。
调整之后：
1. 如果存在未确认的订单，重新打开进程也会触发onResume，所以也会触发后台切换前台的recover；
   登录之后会再调用recover，因为没有待恢复订单，所以会调用recover，但是不会请求后端的接口。
2. 支付未完成，后台之后已经发起的verify请求会中断，返回前台后会自动发起新的verify，会成功；   
3. 正常后台切前台切换也会调用recover，如果不存在待恢复订单，不会请求后端的接口，如果存在，会请求后端verify。


/Users/topjoy/Desktop


## groot学习遇到的问题
1. 模块创建的时候，镜像名称从哪里获取？区服模式和全局模式什么区别？端口名称有什么定义规则TCP_PORT,SERVER_PORT？
![Alt text](image-1.png)
2. 数据库创建的时候，”系统创建的直接填写第三方发布的版本号，可以在dockerhub上搜索使用到的镜像版本“是什么意思？
![Alt text](image.png)
3. 使用到的镜像和数据库等：mongo，redis，zk需要提前在服务器上安装部署好吗？
4. 创建集群的request body参数怎么获取？
'''json
{
  "name":"test-robot-account",
  "description":"",
  "section_ids":"",
  "template_id":82,
  "environments":[],
  "is_lock":false,
  "module_tag_mappings":[
    {"id":3,
     "module":"config",
     "tags":["0.3","latest","0.2","0.1","test_v1"],
     "tag":"0.3"
    },
    {"id":2,
     "module":"global",
     "tags":["latest"],
     "tag":"latest"
    }
  ],
  "temp_environments":[],
  "is_auto_upgrade":false,
  "game_name":"subor"
}
'''
选择对应的dao可用的tag版本，然后groot的功能是实现自动化的部署，client调用groot的接口，会返回一个可用的global地址
https://groot-api.youle.game/api/v1/clusters/summary?game_name=dao
game_name是对应的游戏名称，更换游戏只用更换游戏名称就可以。







